From 0bfd40c4207a1527270c95c0a1d40fcb33a7e59b Mon Sep 17 00:00:00 2001
From: Colin Godsey <crgodsey@gmail.com>
Date: Tue, 16 Apr 2019 07:50:11 -0600
Subject: [PATCH] Waterdog PE (additions)


diff --git a/api/src/main/java/network/ycc/waterdog/api/metrics/RakNetMetrics.java b/api/src/main/java/network/ycc/waterdog/api/metrics/RakNetMetrics.java
new file mode 100644
index 00000000..73495872
--- /dev/null
+++ b/api/src/main/java/network/ycc/waterdog/api/metrics/RakNetMetrics.java
@@ -0,0 +1,7 @@
+package network.ycc.waterdog.api.metrics;
+
+public interface RakNetMetrics {
+    void preCompressionBytes(int i);
+    void postCompressionBytes(int i);
+    void preCompressionPacket(int i);
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/PEBlockRewrite.java b/protocol/src/main/java/network/ycc/waterdog/pe/PEBlockRewrite.java
new file mode 100644
index 00000000..1d85c399
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/PEBlockRewrite.java
@@ -0,0 +1,182 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.buffer.ByteBuf;
+
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+public abstract class PEBlockRewrite {
+
+    public final static PEBlockRewrite EMPTY = new PEBlockRewrite() {
+        public int map(int id) {
+            return id;
+        }
+    };
+
+    protected static final int nV8Blocks = 16 * 16 * 16;
+
+    public abstract int map(int id);
+
+    public void rewriteClientbound(ByteBuf packet, int version) {
+        final int readerIndex = packet.readerIndex();
+        final int packetId = DefinedPacket.readVarInt(packet);
+        final int writerIndex = packet.readerIndex();
+
+        switch (packetId) { //same-size rewrites
+            case 0x3a: //FULL_CHUNK_DATA_PACKET
+                DefinedPacket.readSVarInt(packet); //chunk X
+                DefinedPacket.readSVarInt(packet); //chunk Z
+                final ByteBuf out = packet.alloc().ioBuffer(packet.readableBytes() + 128);
+                int sections, rwStart;
+                try {
+                    if (version >= ProtocolConstants.MINECRAFT_PE_1_12) {
+                        sections = packet.readShortLE();
+                        rwStart = packet.readerIndex();
+                        DefinedPacket.readVarInt(packet); //payload length
+                    } else {
+                        rwStart = packet.readerIndex();
+                        DefinedPacket.readVarInt(packet); //payload length
+                        sections = DefinedPacket.readVarInt(packet);
+                        out.writeByte(sections);
+                    }
+                    rewriteChunkSections(packet, out, sections);
+
+                    packet.readerIndex(readerIndex);
+                    packet.writerIndex(rwStart);
+                    DefinedPacket.writeVarInt(out.readableBytes(), packet); //payload length
+                    packet.writeBytes(out);
+
+                } finally {
+                    out.release();
+                }
+                return;
+            default: // NOOP
+        }
+
+        switch (packetId) { //varint rewrites
+            case 0x15: { //UPDATE_BLOCK_PACKET
+                final int x = DefinedPacket.readSVarInt(packet);
+                final int y = DefinedPacket.readVarInt(packet);
+                final int z = DefinedPacket.readSVarInt(packet);
+                final int id = DefinedPacket.readVarInt(packet);
+                final int flags = DefinedPacket.readVarInt(packet);
+                final int layer = DefinedPacket.readVarInt(packet);
+
+                packet.readerIndex(readerIndex);
+                packet.writerIndex(writerIndex);
+
+                DefinedPacket.writeSVarInt(x, packet);
+                DefinedPacket.writeVarInt(y, packet);
+                DefinedPacket.writeSVarInt(z, packet);
+                DefinedPacket.writeVarInt(map(id), packet);
+                DefinedPacket.writeVarInt(flags, packet);
+                DefinedPacket.writeVarInt(layer, packet);
+                return;
+            }
+            case 0x19: { //LEVEL_EVENT_PACKET
+                final int evID = DefinedPacket.readSVarInt(packet);
+                final float x = packet.readFloatLE();
+                final float y = packet.readFloatLE();
+                final float z = packet.readFloatLE();
+                //should be a svarint, but nukkit does weird things sometimes
+                int data = (int) DefinedPacket.readSVarLong(packet);
+
+                switch (evID) {
+                    case PEDataValues.LEVEL_EVENT_EVENT_TERRAIN_PARTICLE:
+                    case PEDataValues.LEVEL_EVENT_EVENT_PARTICLE_PUNCH_BLOCK:
+                    case PEDataValues.LEVEL_EVENT_EVENT_PARTICLE_DESTROY:
+                        //only rewrite lower 16 bits
+                        final int high = data & 0xFFFF0000;
+                        final int blockID = map(data & 0xFFFF) & 0xFFFF;
+                        data = high | blockID;
+                        break;
+                    default: // NOOP
+                }
+
+                packet.readerIndex(readerIndex);
+                packet.writerIndex(writerIndex);
+
+                DefinedPacket.writeSVarInt(evID, packet);
+                packet.writeFloatLE(x);
+                packet.writeFloatLE(y);
+                packet.writeFloatLE(z);
+                DefinedPacket.writeSVarInt(data, packet);
+                return;
+            }
+            case 0x7b: { //PLAY_LEVEL_SOUND_EVENT_PACKET
+                final int sound = DefinedPacket.readVarInt(packet);
+                final float x = packet.readFloatLE();
+                final float y = packet.readFloatLE();
+                final float z = packet.readFloatLE();
+                int data = DefinedPacket.readSVarInt(packet);
+                final byte[] remaining = new byte[packet.readableBytes()];
+                packet.readBytes(remaining);
+
+                switch (sound) {
+                    case 6: // SOUND_PLACE
+                        data = map(data);
+                        break;
+                    default: // NOOP
+                }
+
+                packet.readerIndex(readerIndex);
+                packet.writerIndex(writerIndex);
+
+                DefinedPacket.writeVarInt(sound, packet);
+                packet.writeFloatLE(x);
+                packet.writeFloatLE(y);
+                packet.writeFloatLE(z);
+                DefinedPacket.writeSVarInt(data, packet);
+                packet.writeBytes(remaining);
+                return;
+            }
+            case 0x0D: //PLAY_ENTITY_SPAWN TODO: entity spawn for fall blocks, DATA_VARIANT
+            default: // NOOP
+        }
+
+        packet.readerIndex(readerIndex);
+    }
+
+    protected void rewriteChunkSections(ByteBuf in, ByteBuf out, int sections) {
+        for (int section = 0 ; section < sections ; section++) {
+            final int subchunkVersion = in.readUnsignedByte();
+            out.writeByte(subchunkVersion);
+            switch (subchunkVersion) {
+                case 0: //legacy block ids, no remap needed
+                case 4: //minet uses this format. what is it?
+                    out.writeBytes(in);
+                    return;
+                case 8: //new form chunk, baked-in palette
+                    rewriteV8ChunkSection(in, out);
+                    break;
+                default: //unsupported
+                    throw new IllegalArgumentException("Unknown subchunk format " + subchunkVersion);
+            }
+        }
+        out.writeBytes(in, 512); //heightmap
+        out.writeBytes(in, 256); //biomedata
+    }
+
+    protected void rewriteV8ChunkSection(ByteBuf in, ByteBuf out) {
+        final int storageCount = in.readUnsignedByte();
+        out.writeByte(storageCount);
+
+        for (int storage = 0 ; storage < storageCount ; storage++) {
+            final int flags = in.readUnsignedByte();
+            final int bitsPerBlock = flags >> 1; //isRuntime = (flags & 0x1) != 0
+            final int blocksPerWord = Integer.SIZE / bitsPerBlock;
+            final int nWords = (nV8Blocks + blocksPerWord - 1) / blocksPerWord;
+
+            out.writeByte(flags);
+            out.writeBytes(in, nWords * Integer.BYTES);
+
+            final int nPaletteEntries = DefinedPacket.readSVarInt(in);
+            DefinedPacket.writeSVarInt(nPaletteEntries, out);
+
+            for (int i = 0 ; i < nPaletteEntries ; i++) {
+                DefinedPacket.writeSVarInt(map(DefinedPacket.readSVarInt(in)), out);
+            }
+        }
+    }
+
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/PEDataValues.java b/protocol/src/main/java/network/ycc/waterdog/pe/PEDataValues.java
new file mode 100644
index 00000000..9d983810
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/PEDataValues.java
@@ -0,0 +1,54 @@
+package network.ycc.waterdog.pe;
+
+import net.md_5.bungee.api.ChatMessageType;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+public class PEDataValues {
+    public static final int CHAT_CLIENT_RAW_TYPE = 0;
+    public static final int CHAT_CLIENT_CHAT_TYPE = 1;
+    public static final int CHAT_CLIENT_TIP_TYPE = 5;
+    public static final int CHAT_CLIENT_SYSTEM_TYPE = 6;
+
+    public static final int PARTICLE_TYPE_TERRAIN = 18;
+
+    public static final int LEVEL_EVENT_EVENT_ADD_PARTICLE_MASK = 0x4000;
+    public static final int LEVEL_EVENT_EVENT_TERRAIN_PARTICLE = LEVEL_EVENT_EVENT_ADD_PARTICLE_MASK | PARTICLE_TYPE_TERRAIN;
+    public static final int LEVEL_EVENT_EVENT_PARTICLE_PUNCH_BLOCK = 2014;
+    public static final int LEVEL_EVENT_EVENT_PARTICLE_DESTROY = 2001;
+
+    public static int getPcChatType(int peId) {
+        switch (peId) {
+            case CHAT_CLIENT_TIP_TYPE: return ChatMessageType.ACTION_BAR.ordinal();
+            case CHAT_CLIENT_SYSTEM_TYPE: return ChatMessageType.SYSTEM.ordinal();
+            default: return ChatMessageType.CHAT.ordinal();
+        }
+    }
+
+    public static int getPeChatType(int pcId, ProtocolConstants.Direction direction) {
+        switch (ChatMessageType.values()[pcId]) {
+            case ACTION_BAR: return CHAT_CLIENT_TIP_TYPE;
+            case SYSTEM: return CHAT_CLIENT_SYSTEM_TYPE;
+            default:
+                return direction == ProtocolConstants.Direction.TO_SERVER ?
+                        CHAT_CLIENT_CHAT_TYPE : CHAT_CLIENT_RAW_TYPE;
+        }
+    }
+
+    public static int getPeDimensionId(int dimId) {
+        switch (dimId) {
+            case -1: return 1;
+            case 1: return 2;
+            case 0: return 0;
+            default: throw new IllegalArgumentException("Unknown dim id " + dimId);
+        }
+    }
+
+    public static int getPcDimensionId(int dimId) {
+        switch (dimId) {
+            case 1: return -1;
+            case 2: return 1;
+            case 0: return 0;
+            default: throw new IllegalArgumentException("Unknown dim id " + dimId);
+        }
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/PERawPacketData.java b/protocol/src/main/java/network/ycc/waterdog/pe/PERawPacketData.java
new file mode 100644
index 00000000..55ca27bd
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/PERawPacketData.java
@@ -0,0 +1,176 @@
+package network.ycc.waterdog.pe;
+
+import com.google.common.base.Preconditions;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
+
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+import java.util.UUID;
+
+public class PERawPacketData {
+    protected static final int PLAYER_ACTION_ID = 36;
+    protected static final int EXT_PS_AWAIT_DIM_SWITCH_ACK_ID = -100;
+    protected static final int DIMENSION_CHANGE_ACK = 14;
+
+    private static final byte[] fakePEChunkData;
+    private static final byte[] fakePEChunkData112;
+
+    static {
+        final ByteBuf serializer = Unpooled.buffer();
+        final ByteBuf chunkdata = Unpooled.buffer();
+
+        chunkdata.writeByte(1); //1 section
+        chunkdata.writeByte(8); //New subchunk version!
+        chunkdata.writeByte(1); //Zero blockstorages :O
+        chunkdata.writeByte((1 << 1) | 1);  //Runtimeflag and palette id.
+        chunkdata.writeZero(512);
+        DefinedPacket.writeSVarInt(1, chunkdata); //Palette size
+        DefinedPacket.writeSVarInt(0, chunkdata); //Air
+        chunkdata.writeZero(512); //heightmap.
+        chunkdata.writeZero(256); //Biomedata.
+        chunkdata.writeByte(0); //borders
+
+        chunkdata.markReaderIndex();
+        DefinedPacket.writeVarInt(chunkdata.readableBytes(), serializer);
+        serializer.writeBytes(chunkdata);
+        fakePEChunkData = new byte[serializer.readableBytes()];
+        serializer.readBytes(fakePEChunkData);
+
+        // 1.12 chunks
+        chunkdata.resetReaderIndex();
+        ByteBuf buf112 = Unpooled.buffer();
+        DefinedPacket.writeVarInt(chunkdata.readUnsignedByte(), buf112);
+        buf112.writeByte(0);
+        DefinedPacket.writeVarInt(chunkdata.readableBytes(), buf112);
+        buf112.writeBytes(chunkdata);
+        fakePEChunkData112 = new byte[buf112.readableBytes()];
+        buf112.readBytes(fakePEChunkData112);
+
+        Preconditions.checkArgument(fakePEChunkData.length > 0);
+        Preconditions.checkArgument(fakePEChunkData112.length > 0);
+    }
+
+    public static int peekPacketId(ByteBuf from) {
+        if (!from.isReadable()) {
+            return -1;
+        }
+        try {
+            return DefinedPacket.readVarInt(from.markReaderIndex());
+        } finally {
+            from.resetReaderIndex();
+        }
+    }
+
+    public static boolean isDimSwitchAck(ByteBuf data) {
+        if (peekPacketId(data) == PLAYER_ACTION_ID) {
+            final ByteBuf copy = data.duplicate();
+            DefinedPacket.readVarInt(copy);
+            DefinedPacket.readVarLong(copy); // entity id
+            return DefinedPacket.readSVarInt(copy) == DIMENSION_CHANGE_ACK;
+        }
+        return false;
+    }
+
+    public static void injectChunkPublisherUpdate(Channel channel, int x, int y, int z) {
+        final ByteBuf publisherUpdate = channel.alloc().ioBuffer();
+        DefinedPacket.writeVarInt(0x79, publisherUpdate); //CHUNK_PUBLISHER_UPDATE_PACKET
+        DefinedPacket.writeSVarInt(x, publisherUpdate);
+        DefinedPacket.writeVarInt(y, publisherUpdate);
+        DefinedPacket.writeSVarInt(z, publisherUpdate);
+        DefinedPacket.writeVarInt(300, publisherUpdate);
+        channel.write(publisherUpdate);
+    }
+
+    public static void injectForcedDimChange(Channel channel, int version) {
+        injectChunkPublisherUpdate(channel, 0, 0, 0);
+        for (int x = -4; x <= 4; x++) {
+            for (int z = -4; z <= 4; z++) {
+                ByteBuf buffer = channel.alloc().ioBuffer();
+                DefinedPacket.writeVarInt(0x3A, buffer); //PLAY_CHUNK_DATA
+                DefinedPacket.writeSVarInt(x, buffer);
+                DefinedPacket.writeSVarInt(z, buffer);
+                if (version >= ProtocolConstants.MINECRAFT_PE_1_12) {
+                    buffer.writeBytes(fakePEChunkData112);
+                } else {
+                    buffer.writeBytes(fakePEChunkData);
+                }
+                channel.write(buffer);
+            }
+        }
+        final ByteBuf lockPacket = channel.alloc().ioBuffer();
+        DefinedPacket.writeVarInt(EXT_PS_AWAIT_DIM_SWITCH_ACK_ID, lockPacket);
+        channel.writeAndFlush(lockPacket);
+    }
+
+    public static void injectGameMode(Channel channel, int gamemode) {
+        final ByteBuf gameMode = channel.alloc().ioBuffer();
+        DefinedPacket.writeVarInt(0x3E, gameMode); //PLAY_PLAYER_GAME_TYPE
+        DefinedPacket.writeSVarInt(gamemode, gameMode);
+        channel.writeAndFlush(gameMode);
+    }
+
+    public static void injectRemoveEntity(Channel channel, long entityId) {
+        final ByteBuf removeEntity = channel.alloc().ioBuffer();
+        DefinedPacket.writeVarInt(0x0E, removeEntity); //PLAY_ENTITY_DESTROY
+        DefinedPacket.writeSVarLong(entityId, removeEntity);
+        channel.write(removeEntity);
+    }
+
+    public static void injectRemovePlayerList(Channel channel, UUID uuid) {
+        final ByteBuf removePlayerList = channel.alloc().ioBuffer();
+        DefinedPacket.writeVarInt(0x3F, removePlayerList); //PLAY_PLAYER_INFO
+        DefinedPacket.writeVarInt(1, removePlayerList); //remove
+        DefinedPacket.writeVarInt(1, removePlayerList); //1 item
+        removePlayerList.writeLongLE(uuid.getMostSignificantBits());
+        removePlayerList.writeLongLE(uuid.getLeastSignificantBits());
+        channel.write(removePlayerList);
+    }
+
+    public static void injectResourcePackInfo(Channel channel, PEResourcePackData pack) {
+        final ByteBuf resourcePackInfo = channel.alloc().ioBuffer();
+        DefinedPacket.writeVarInt(0x52, resourcePackInfo); //PLAY_RESOURCE_PACK_INFO
+        DefinedPacket.writeString(pack.getUuid().toString(), resourcePackInfo);
+        resourcePackInfo.writeIntLE(PEResourcePackData.CHUNK_SIZE);
+        resourcePackInfo.writeIntLE(pack.getNumberChunks());
+        resourcePackInfo.writeLongLE(pack.getSize());
+        DefinedPacket.writeVarInt(pack.getSha256().length, resourcePackInfo);
+        resourcePackInfo.writeBytes(pack.getSha256());
+        resourcePackInfo.writeBoolean(false); //premium
+        resourcePackInfo.writeByte(1); //resource pack
+        channel.write(resourcePackInfo);
+    }
+
+    public static void injectResourcePackData(Channel channel, PEResourcePackData pack, int chunkIndex, int version) {
+        final ByteBuf resourcePackData = channel.alloc().ioBuffer();
+        DefinedPacket.writeVarInt(0x53, resourcePackData); //PLAY_RESOURCE_PACK_DATA
+        DefinedPacket.writeString(pack.getUuid().toString(), resourcePackData);
+        resourcePackData.writeIntLE(chunkIndex);
+        resourcePackData.writeLongLE(PEResourcePackData.CHUNK_SIZE * chunkIndex);
+        pack.writeChunk(chunkIndex, resourcePackData, version);
+        channel.write(resourcePackData);
+    }
+
+    public static void injectRemoveAllEffects(Channel channel, long clientEntityId) {
+        for (int i = 0 ; i < 30 ; i++) {
+            injectRemoveEntityEffect(channel, clientEntityId, i);
+        }
+        channel.flush();
+    }
+
+    public static void injectRemoveEntityEffect(Channel channel, long entityId, int effectId) {
+        final ByteBuf removeEntityEffect = channel.alloc().ioBuffer();
+        DefinedPacket.writeVarInt(0x1C, removeEntityEffect); //PLAY_ENTITY_EFFECT
+        DefinedPacket.writeVarLong(entityId, removeEntityEffect);
+        removeEntityEffect.writeByte(3); //remove effect
+        DefinedPacket.writeSVarInt(effectId, removeEntityEffect);
+        DefinedPacket.writeSVarInt(0, removeEntityEffect); // unused
+        removeEntityEffect.writeBoolean(false); // unused
+        DefinedPacket.writeSVarInt(0, removeEntityEffect); // unused
+        channel.write(removeEntityEffect);
+    }
+
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/PEResourcePackData.java b/protocol/src/main/java/network/ycc/waterdog/pe/PEResourcePackData.java
new file mode 100644
index 00000000..33d96c53
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/PEResourcePackData.java
@@ -0,0 +1,20 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.buffer.ByteBuf;
+
+import java.util.UUID;
+
+public interface PEResourcePackData {
+    int CHUNK_SIZE = 1024 * 1024;
+
+    void writeChunk(int chunkIndex, ByteBuf to, int version);
+    String getName();
+    UUID getUuid();
+    String getVersion();
+    int getSize();
+    byte[] getSha256();
+
+    default int getNumberChunks() {
+        return (getSize() + CHUNK_SIZE - 1) / CHUNK_SIZE;
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PECommand.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PECommand.java
new file mode 100644
index 00000000..94786b16
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PECommand.java
@@ -0,0 +1,37 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+@Data
+@NoArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PECommand extends DefinedPacket {
+    String message;
+    private byte[] data;
+
+    @Override
+    public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        setMessage(readString(buf));
+        data = new byte[buf.readableBytes()];
+        buf.readBytes(data);
+    }
+
+    @Override
+    public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        writeString(getMessage(), buf);
+        buf.writeBytes(data);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionRequest.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionRequest.java
new file mode 100644
index 00000000..75784080
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionRequest.java
@@ -0,0 +1,31 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+public class PEEncryptionRequest extends DefinedPacket {
+    private String jwtData;
+
+    @Override
+    public void read(ByteBuf buf) {
+        jwtData = readString(buf);
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        writeString(jwtData, buf);
+    }
+
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionResponse.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionResponse.java
new file mode 100644
index 00000000..b0529006
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionResponse.java
@@ -0,0 +1,27 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+public class PEEncryptionResponse extends DefinedPacket {
+    @Override
+    public void write(ByteBuf buf) {
+
+    }
+
+    @Override
+    public void read(ByteBuf buf) {
+        buf.skipBytes(buf.readableBytes());
+    }
+
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEHandshake.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEHandshake.java
new file mode 100644
index 00000000..9aa4df45
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEHandshake.java
@@ -0,0 +1,53 @@
+package network.ycc.waterdog.pe.packet;
+
+import com.google.gson.JsonObject;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+
+import net.md_5.bungee.protocol.packet.Handshake;
+
+import java.math.BigInteger;
+import java.security.PublicKey;
+import java.util.UUID;
+
+@Data
+@EqualsAndHashCode(callSuper = false)
+public class PEHandshake extends Handshake {
+    private String username;
+    private UUID uuid;
+    private UUID loginUUID;
+    private BigInteger xuid;
+    private boolean authorized;
+    private JsonObject clientInfo;
+    private byte[] handshakeData;
+    private PublicKey publicKey;
+
+    public PEHandshake() {
+        setProtocolVersion(2);
+    }
+
+    public PEHandshake(int protocolVersion, String host, int port, String username, UUID uuid,
+            boolean authorized, JsonObject clientInfo, BigInteger xuid) {
+        super(protocolVersion, host, port, 2);
+        this.username = username;
+        this.uuid = uuid;
+        this.authorized = authorized;
+        this.clientInfo = clientInfo;
+        this.xuid = xuid;
+    }
+
+    @Override
+    public void read(ByteBuf buf) {
+        handshakeData = new byte[buf.readableBytes()];
+        buf.readBytes(handshakeData);
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        buf.writeBytes(handshakeData);
+    }
+
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELocalPlayerInitialized.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELocalPlayerInitialized.java
new file mode 100644
index 00000000..e0c0b55f
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELocalPlayerInitialized.java
@@ -0,0 +1,34 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PELocalPlayerInitialized extends DefinedPacket {
+    private long playerId;
+
+    @Override
+    public void read(ByteBuf buf) {
+        playerId = readVarLong(buf);
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        writeVarLong(playerId, buf);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELogin.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELogin.java
new file mode 100644
index 00000000..88528127
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELogin.java
@@ -0,0 +1,163 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+import net.md_5.bungee.protocol.packet.Login;
+import network.ycc.waterdog.pe.PEDataValues;
+
+@Data
+@NoArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PELogin extends Login {
+    private float spawnX;
+    private float spawnY;
+    private float spawnZ;
+    private byte[] tailPayload;
+    private int payloadPaletteOffset; //offset of tailPayload for the palette
+    private int payloadPaletteLength;
+
+    public PELogin(int entityId, short gameMode, int dimension, short difficulty, short maxPlayers, String levelType, int viewDistance, boolean reducedDebugInfo, byte[] tailPayload) {
+        super(entityId, gameMode, dimension, difficulty, maxPlayers, levelType, viewDistance, reducedDebugInfo);
+        this.tailPayload = tailPayload;
+    }
+
+    @Override
+    public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        readSVarLong(buf); //entity id (but it's actually signed varlong, so we use the field below, which is unsigned)
+        setEntityId((int) readVarLong(buf));
+        setGameMode((short) readSVarInt(buf));
+        spawnX = buf.readFloatLE(); //x
+        spawnY = buf.readFloatLE(); //y
+        spawnZ = buf.readFloatLE(); //z
+        buf.readFloatLE(); //yaw
+        buf.readFloatLE(); //pitch
+        readSVarInt(buf); //seed
+        setDimension(PEDataValues.getPcDimensionId(readSVarInt(buf)));
+        readSVarInt(buf); //world type (1 - infinite)
+        readSVarInt(buf); //world gamemode (SURVIVAL)
+        setDifficulty((short) readSVarInt(buf));
+
+        final int payloadStartIndex = buf.readerIndex();
+        tailPayload = new byte[buf.readableBytes()];
+        buf.readBytes(tailPayload);
+        buf.readerIndex(payloadStartIndex);
+
+        DefinedPacket.readSVarInt(buf); //spawn position
+        DefinedPacket.readSVarLong(buf); //should be VarInt, but nukkit...
+        DefinedPacket.readSVarInt(buf);
+        buf.readBoolean(); //disable achievements
+        DefinedPacket.readSVarInt(buf); //time
+        buf.readBoolean(); //edu mode
+        buf.readBoolean(); //edu features
+        buf.readFloatLE(); //rain level
+        buf.readFloatLE(); //lighting level
+        if (protocolVersion >= ProtocolConstants.MINECRAFT_PE_1_9) {
+            buf.readBoolean(); //???
+        }
+        buf.readBoolean(); //is multiplayer
+        buf.readBoolean(); //broadcast to lan
+        if (protocolVersion >= ProtocolConstants.MINECRAFT_PE_1_9) {
+            DefinedPacket.readSVarInt(buf); //xbox live broadcast, 3 = friends of friends
+            DefinedPacket.readSVarInt(buf); //platform broadcast
+        } else {
+            buf.readBoolean(); //broadcast to xbl
+        }
+        buf.readBoolean(); //commands enabled
+        buf.readBoolean(); //needs texture pack
+        
+        final int nGameRules = DefinedPacket.readVarInt(buf); //game rules
+        for (int i = 0 ; i < nGameRules ; i++) {
+            DefinedPacket.readString(buf);
+            final int grType = DefinedPacket.readVarInt(buf);
+            switch (grType) {
+                case 1: {
+                    buf.readByte();
+                    break;
+                }
+                case 2: {
+                    DefinedPacket.readSVarInt(buf);
+                    break;
+                }
+                case 3: {
+                    buf.readFloatLE();
+                    break;
+                }
+                default:
+                    throw new IllegalArgumentException("Unknown game rule type " + grType);
+            }
+        }
+
+        buf.readBoolean(); //bonus chest
+        buf.readBoolean(); //player map enabled
+        if (protocolVersion < ProtocolConstants.MINECRAFT_PE_1_9) {
+            buf.readBoolean(); //trust players
+        }
+        DefinedPacket.readSVarInt(buf); //permission level
+        if (protocolVersion < ProtocolConstants.MINECRAFT_PE_1_9) {
+            DefinedPacket.readSVarInt(buf); //game publish setting
+        }
+        buf.readIntLE(); //Server chunk tick radius..
+        if (protocolVersion < ProtocolConstants.MINECRAFT_PE_1_9) {
+            buf.readBoolean(); //Platformbroadcast
+            DefinedPacket.readSVarInt(buf); //Broadcast mode
+            buf.readBoolean(); //Broadcast intent
+        }
+        buf.readBoolean(); //hasLockedRes pack
+        buf.readBoolean(); //hasLockedBeh pack
+        buf.readBoolean(); //hasLocked world template.
+        buf.readBoolean(); //Microsoft GamerTags only. Hell no!
+        buf.readBoolean(); //is from world template
+        buf.readBoolean(); //is world template option locked
+        if (protocolVersion >= ProtocolConstants.MINECRAFT_PE_1_12) {
+            buf.readByte(); //only spawn v1 villagers
+        }
+        if (protocolVersion >= ProtocolConstants.MINECRAFT_PE_1_13) {
+            DefinedPacket.readString(buf); //vanilla version
+        }
+        DefinedPacket.readString(buf); //level ID (empty string)
+        DefinedPacket.readString(buf); //world name (empty string)
+        DefinedPacket.readString(buf); //premium world template id (empty string)
+        buf.readBoolean(); //is trial
+        buf.readLongLE(); //world ticks
+        DefinedPacket.readSVarInt(buf); //enchantment seed FFS MOJANG
+
+        final int paletteItems = DefinedPacket.readVarInt(buf);
+        final int paletteStart = buf.readerIndex();
+        for (int i = 0 ; i < paletteItems ; i++) {
+            final int strLength = DefinedPacket.readVarInt(buf);
+            if (protocolVersion >= ProtocolConstants.MINECRAFT_PE_1_12) {
+                buf.skipBytes(strLength + 4);
+            } else {
+                buf.skipBytes(strLength + 2);
+            }
+        }
+        payloadPaletteOffset = paletteStart - payloadStartIndex;
+        payloadPaletteLength = buf.readerIndex() - paletteStart;
+
+        buf.skipBytes(buf.readableBytes()); //skip the rest
+    }
+
+    @Override
+    public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        writeSVarLong(getEntityId(), buf);
+        writeVarLong(getEntityId(), buf);
+        writeSVarInt(getGameMode(), buf);
+        buf.writeFloatLE(spawnX); //player x
+        buf.writeFloatLE(spawnY); //player y
+        buf.writeFloatLE(spawnZ); //player z
+        buf.writeFloatLE(0); //player pitch
+        buf.writeFloatLE(0); //player yaw
+        writeSVarInt(0, buf); //seed
+        writeSVarInt(PEDataValues.getPeDimensionId(getDimension()), buf); //world dimension
+        writeSVarInt(1, buf); //world type (1 - infinite)
+        writeSVarInt(0, buf); //world gamemode
+        writeSVarInt(getDifficulty(), buf); //world difficulty
+        buf.writeBytes(tailPayload);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PERemoveObjectivePacket.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PERemoveObjectivePacket.java
new file mode 100644
index 00000000..7fe81e63
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PERemoveObjectivePacket.java
@@ -0,0 +1,34 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PERemoveObjectivePacket extends DefinedPacket {
+    private String objectiveName;
+
+    @Override
+    public void write(ByteBuf buf) {
+        writeString(objectiveName, buf);
+    }
+
+    @Override
+    public void read(ByteBuf buf) {
+        objectiveName = readString(buf);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePack.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePack.java
new file mode 100644
index 00000000..86529798
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePack.java
@@ -0,0 +1,59 @@
+package network.ycc.waterdog.pe.packet;
+
+import network.ycc.waterdog.pe.PEResourcePackData;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.AllArgsConstructor;
+import lombok.NoArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PEResourcePack extends DefinedPacket {
+    private boolean required = true;
+    private PEResourcePackData[] resourcePacks = null;
+    private PEResourcePackData[] behaviorPacks = null;
+
+    @Override
+    public void read(ByteBuf buf) {
+        buf.skipBytes(buf.readableBytes());
+    }
+
+    @Override
+    public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        buf.writeBoolean(required);
+        buf.writeBoolean(false); // has scripts
+        writePacks(buf, behaviorPacks, protocolVersion);
+        writePacks(buf, resourcePacks, protocolVersion);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+
+    protected void writePacks(ByteBuf buf, PEResourcePackData[] packs, int protocolVersion) {
+        buf.writeShortLE(packs == null ? 0 : packs.length);
+        if (packs != null) {
+            for (PEResourcePackData pack : packs) {
+                writeString(pack.getUuid().toString(), buf);
+                writeString(pack.getVersion(), buf);
+                buf.writeLongLE(pack.getSize());
+                writeString("", buf); //encryption key
+                writeString("", buf); //sub-pack name
+                writeString("", buf); //content identity
+                if (protocolVersion >= ProtocolConstants.MINECRAFT_PE_1_9) {
+                    buf.writeBoolean(false); // has scripts
+                }
+            }
+        }
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePackChunkRequest.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePackChunkRequest.java
new file mode 100644
index 00000000..3e885021
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePackChunkRequest.java
@@ -0,0 +1,28 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import java.util.UUID;
+
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@EqualsAndHashCode(callSuper = false)
+public class PEResourcePackChunkRequest extends DefinedPacket {
+    private UUID packUUID;
+    private int chunkIndex;
+
+    @Override
+    public void read(ByteBuf buf) {
+        packUUID = UUID.fromString(readString(buf));
+        chunkIndex = buf.readIntLE();
+    }
+
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePackResponse.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePackResponse.java
new file mode 100644
index 00000000..32e761d5
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePackResponse.java
@@ -0,0 +1,60 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import java.util.ArrayList;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+
+import lombok.NoArgsConstructor;
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PEResourcePackResponse extends DefinedPacket {
+    public static final byte STATUS_REFUSED = 1;
+    public static final byte STATUS_SEND_PACKS = 2;
+    public static final byte STATUS_HAVE_ALL_PACKS = 3;
+    public static final byte STATUS_COMPLETED = 4;
+
+    private int status;
+    private String[] packs = new String[0];
+
+    public PEResourcePackResponse(int status) {
+        this(status, null);
+    }
+
+    @Override
+    public void read(ByteBuf buf) {
+        status = buf.readUnsignedByte();
+        final int entryCount = buf.readShortLE();
+        final ArrayList<String> packList = new ArrayList<>();
+        for (int i = 0 ; i < entryCount ; i++) {
+            packList.add(readString(buf));
+        }
+        packs = packList.toArray(packs);
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        buf.writeByte(status);
+        if (packs == null) {
+            buf.writeShortLE(0);
+        } else {
+            buf.writeShortLE(packs.length);
+            for (String pack : packs) {
+                writeString(pack, buf);
+            }
+        }
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourceStack.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourceStack.java
new file mode 100644
index 00000000..a17e9e3e
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourceStack.java
@@ -0,0 +1,53 @@
+package network.ycc.waterdog.pe.packet;
+
+import network.ycc.waterdog.pe.PEResourcePackData;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.AllArgsConstructor;
+import lombok.NoArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PEResourceStack extends DefinedPacket {
+    private boolean required = true;
+    private boolean isExperimental = true;
+    private PEResourcePackData[] resourcePacks = null;
+    private PEResourcePackData[] behaviorPacks = null;
+
+    @Override
+    public void read(ByteBuf buf) {
+        buf.skipBytes(buf.readableBytes());
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        buf.writeBoolean(required);
+        writePacks(buf, behaviorPacks);
+        writePacks(buf, resourcePacks);
+        buf.writeBoolean(isExperimental);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+
+    protected void writePacks(ByteBuf buf, PEResourcePackData[] packs) {
+        writeVarInt(packs == null ? 0 : packs.length, buf);
+        if (packs != null) {
+            for (PEResourcePackData pack : packs) {
+                writeString(pack.getUuid().toString(), buf);
+                writeString(pack.getVersion(), buf);
+                writeString("", buf); //sub package name
+            }
+        }
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PESetDisplayObjectivePacket.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PESetDisplayObjectivePacket.java
new file mode 100644
index 00000000..c6eb87eb
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PESetDisplayObjectivePacket.java
@@ -0,0 +1,46 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PESetDisplayObjectivePacket extends DefinedPacket {
+    private String displaySlot;
+    private String objectiveName;
+    private String displayName;
+    private String criteriaName;
+    private int sortOrder;
+
+    @Override
+    public void write(ByteBuf buf) {
+        writeString(displaySlot, buf);
+        writeString(objectiveName, buf);
+        writeString(displayName, buf);
+        writeString(criteriaName, buf);
+        buf.writeByte(sortOrder);
+    }
+
+    @Override
+    public void read(ByteBuf buf) {
+        displaySlot = readString(buf);
+        objectiveName = readString(buf);
+        displayName = readString(buf);
+        criteriaName = readString(buf);
+        sortOrder = buf.readUnsignedByte();
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEStopSoundPacket.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEStopSoundPacket.java
new file mode 100644
index 00000000..dab227a1
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEStopSoundPacket.java
@@ -0,0 +1,35 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PEStopSoundPacket extends DefinedPacket {
+
+    public String name;
+    public boolean stopAll;
+
+    @Override
+    public void read( ByteBuf buf ) {
+        //Ignore
+    }
+
+    @Override
+    public void write( ByteBuf buf ) {
+        writeString( name, buf );
+        buf.writeBoolean( stopAll );
+    }
+
+    @Override
+    public void handle( AbstractPacketHandler handler ) throws Exception {
+
+    }
+}
\ No newline at end of file
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PETransfer.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PETransfer.java
new file mode 100644
index 00000000..0a5d0f6f
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PETransfer.java
@@ -0,0 +1,39 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PETransfer extends DefinedPacket {
+    String host;
+    int port;
+
+    @Override
+    public void read(ByteBuf buf)
+    {
+        host = readString(buf);
+        port = buf.readUnsignedShortLE();
+    }
+
+    @Override
+    public void write(ByteBuf buf)
+    {
+        writeString(host, buf);
+        buf.writeShortLE(port);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        //TODO: real handler to handle server drive transfer. should remember the server if we can
+    }
+}
diff --git a/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap_PE.java b/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap_PE.java
new file mode 100644
index 00000000..fe6344fa
--- /dev/null
+++ b/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap_PE.java
@@ -0,0 +1,248 @@
+package net.md_5.bungee.entitymap;
+
+import io.netty.buffer.ByteBuf;
+
+import net.md_5.bungee.protocol.DefinedPacket;
+
+import java.util.UUID;
+import java.util.function.Consumer;
+import java.util.function.LongConsumer;
+
+public class EntityMap_PE extends EntityMap {
+
+    static final EntityMap_PE INSTANCE = new EntityMap_PE();
+
+    @Override
+    public void rewriteServerbound(ByteBuf packet, int oldId, int newId) {
+        doRewrite(packet, oldId, newId);
+    }
+
+    @Override
+    public void rewriteClientbound(ByteBuf from, int oldId, int newId) {
+        doRewrite(from, oldId, newId);
+    }
+
+    public void doRewrite(ByteBuf from, int oldId, int newId) {
+        if (!from.isReadable()) {
+            return;
+        }
+        final ByteBuf to = from.duplicate();
+        final int originalReader = from.readerIndex();
+        final int packetId = DefinedPacket.readVarInt(from);
+        final Consumer<Rewrite> act = cmd -> cmd.rewrite(from, to, oldId, newId);
+
+        to.readerIndex(to.readerIndex() - 16); //rewrite in place, but with 16 byte lead
+        to.writerIndex(to.readerIndex());
+        DefinedPacket.writeVarInt(packetId, to);
+
+        switch (packetId) {
+            case 0x12: //PLAY_ENTITY_TELEPORT
+            case 0x1B: //PLAY_ENTITY_STATUS
+            case 0x1C: //PLAY_ENTITY_EFFECT
+            case 0x1D: //PLAY_ENTITY_ATTRIBUTES
+            case 0x1F: //PLAY_MOB_EQUIPMENT
+            case 0x24: //PLAY_PLAYER_ACTION
+            case 0x27: //PLAY_ENTITY_METADATA
+            case 0x28: //PLAY_ENTITY_VELOCITY
+            case 0x6F: //PLAY_MOVE_ENTITY_DELTA
+            case 0x71: //PLAY_LOCAL_PLAYER_INITIALIZED
+                act.accept(VARLONG);
+                break;
+            case 0x0C: //PLAY_SPAWN_PLAYER
+                to.writeBytes(from, Long.BYTES * 2);
+                act.accept(SK_VI_DATA);
+                act.accept(SVARLONG);
+                act.accept(VARLONG);
+                break;
+            case 0x0D: //PLAY_ENTITY_SPAWN
+            case 0x0F: //PLAY_ADD_ITEM_ENTITY
+            case 0x16: //PLAY_ADD_PAINTING_PACKET
+                act.accept(SVARLONG); //unique id
+                act.accept(VARLONG); //runtime id
+                break;
+            case 0x0E: //PLAY_ENTITY_DESTROY
+            case 0x4A: //PLAY_BOSS_EVENT
+                act.accept(SVARLONG);
+                break;
+            case 0x11: //PLAY_ENTITY_COLLECT_EFFECT
+                act.accept(VARLONG);
+                act.accept(VARLONG);
+                break;
+            case 0x13: //PLAY_PLAYER_MOVE_LOOK
+                act.accept(VARLONG);
+                to.writeBytes(from, Float.BYTES * 6 + Byte.BYTES * 2);
+                act.accept(VARLONG);
+                break;
+            case 0x21: //PLAY_INTERACT
+                to.writeBytes(from, 1);
+                act.accept(VARLONG);
+                break;
+            case 0x29: //PLAY_ENTITY_PASSENGER
+                act.accept(SVARLONG);
+                act.accept(SVARLONG);
+                break;
+            case 0x2C: //PLAY_ENTITY_ANIMATION
+                act.accept(SK_SVARINT);
+                act.accept(VARLONG);
+                break;
+            case 0x37: { //PLAY_ADVENTURE_SETTINGS
+                final int idIndex = from.writerIndex() - Long.BYTES;
+                final long id = from.getLongLE(idIndex);
+                from.setLongLE(idIndex, id == oldId ? newId : (id == newId ? oldId : id));
+                from.readerIndex(originalReader);
+                return;
+            }
+            case 0x3F: { //PLAY_PLAYER_INFO
+                final int type = from.readUnsignedByte();
+                final int num = DefinedPacket.readVarInt(from);
+                to.writeByte(type);
+                DefinedPacket.writeVarInt(num, to);
+                if (type == 0) { //ADD
+                    for (int i = 0; i < num; i++) {
+                        to.writeBytes(from, Long.BYTES * 2);
+                        act.accept(SVARLONG);
+                        act.accept(SK_VI_DATA); //username
+                        act.accept(SK_VI_DATA); //skin name
+                        act.accept(SK_VI_DATA); //skin data
+                        act.accept(SK_VI_DATA); //cape data
+                        act.accept(SK_VI_DATA); //geom name
+                        act.accept(SK_VI_DATA); //geom data
+                        act.accept(SK_VI_DATA); //xuid
+                        act.accept(SK_VI_DATA); //channel
+                    }
+                }
+                break;
+            }
+            case 0x50: //PLAY_TRADE_UPDATE
+                to.writeBytes(from, 2);
+                act.accept(SK_SVARINT);
+                act.accept(SK_SVARINT);
+                act.accept(SK_SVARINT);
+                to.writeBytes(from, 1);
+                act.accept(SVARLONG);
+                act.accept(SVARLONG);
+                break;
+            default:
+                from.readerIndex(originalReader);
+                return;
+        }
+
+        to.writeBytes(from); //copy the rest
+
+        from.readerIndex(to.readerIndex());
+        from.writerIndex(to.writerIndex());
+    }
+
+    public void entityTrack(ByteBuf packet, LongConsumer add, LongConsumer remove) {
+        if (!packet.isReadable()) {
+            return;
+        }
+        final int readerIndex = packet.readerIndex();
+        switch (DefinedPacket.readVarInt(packet)) {
+            case 0x0C: //PLAY_SPAWN_PLAYER
+                packet.skipBytes(Long.BYTES * 2);
+                DefinedPacket.readString(packet);
+                DefinedPacket.readSVarLong(packet); //unique ID
+                add.accept(DefinedPacket.readVarLong(packet));
+                break;
+            case 0x0D: //PLAY_ENTITY_SPAWN
+            case 0x0F: //PLAY_ADD_ITEM_ENTITY
+            case 0x16: //PLAY_ADD_PAINTING_PACKET
+                DefinedPacket.readSVarLong(packet);
+                add.accept(DefinedPacket.readVarLong(packet));
+                break;
+            case 0x0E: //PLAY_ENTITY_DESTROY
+                remove.accept(DefinedPacket.readSVarLong(packet));
+                break;
+            default: // NOOP
+        }
+
+        packet.readerIndex(readerIndex);
+    }
+
+    public void playerListTrackRewrite(ByteBuf packet, Consumer<UUID> add, Consumer<UUID> remove, UUID playerUUID, UUID loginUUID) {
+        if (!packet.isReadable()) {
+            return;
+        }
+        final int readerIndex = packet.readerIndex();
+        final Runnable rewrite = () -> {
+            final int preUUIDReaderIndex = packet.readerIndex();
+            final long msb = packet.readLongLE();
+            final long lsb = packet.readLongLE();
+            if (msb == playerUUID.getMostSignificantBits()
+                    && lsb == playerUUID.getLeastSignificantBits()) {
+                packet.setLongLE(preUUIDReaderIndex, loginUUID.getMostSignificantBits());
+                packet.setLongLE(preUUIDReaderIndex + Long.BYTES, loginUUID.getLeastSignificantBits());
+            } else if (msb == loginUUID.getMostSignificantBits()
+                    && lsb == loginUUID.getLeastSignificantBits()) {
+                packet.setLongLE(preUUIDReaderIndex, playerUUID.getMostSignificantBits());
+                packet.setLongLE(preUUIDReaderIndex + Long.BYTES, playerUUID.getLeastSignificantBits());
+            }
+        };
+        switch (DefinedPacket.readVarInt(packet)) {
+            case 0x3F: { //PLAY_PLAYER_INFO
+                final int type = packet.readUnsignedByte();
+                final int num = DefinedPacket.readVarInt(packet);
+                if (type == 0) { //ADD
+                    for (int i = 0; i < num; i++) {
+                        final int preUUIDReaderIndex = packet.readerIndex();
+                        add.accept(new UUID(packet.readLongLE(), packet.readLongLE()));
+                        packet.readerIndex(preUUIDReaderIndex);
+                        
+                        rewrite.run();
+                        DefinedPacket.readSVarLong(packet); //entity id
+                        packet.skipBytes(DefinedPacket.readVarInt(packet)); //username
+                        packet.skipBytes(DefinedPacket.readVarInt(packet)); //skin name
+                        packet.skipBytes(DefinedPacket.readVarInt(packet)); //skin data
+                        packet.skipBytes(DefinedPacket.readVarInt(packet)); //cape data
+                        packet.skipBytes(DefinedPacket.readVarInt(packet)); //geom name
+                        packet.skipBytes(DefinedPacket.readVarInt(packet)); //geom data
+                        packet.skipBytes(DefinedPacket.readVarInt(packet)); //xuid
+                        packet.skipBytes(DefinedPacket.readVarInt(packet)); //channel
+                    }
+                } else if (type == 1) { //REMOVE
+                    for (int i = 0; i < num; i++) {
+                        final long msb = packet.readLongLE();
+                        final long lsb = packet.readLongLE();
+                        remove.accept(new UUID(msb, lsb));
+                    }
+                }
+                break;
+            }
+            case 0x5D: { //PLAY_PLAYER_SKIN_PACKET
+                rewrite.run();
+                break;
+            }
+            default: // NOOP
+        }
+
+        packet.readerIndex(readerIndex);
+    }
+
+    public interface Rewrite {
+        void rewrite(ByteBuf from, ByteBuf to, int oldId, int newId);
+    }
+
+    static public final Rewrite SK_VI_DATA = (from, to, oldId, newId) -> {
+        final int length = DefinedPacket.readVarInt(from);
+        DefinedPacket.writeVarInt(length, to);
+        to.writeBytes(from, length);
+    };
+
+    static public final Rewrite SK_SVARINT = (from, to, oldId, newId) ->
+            DefinedPacket.writeSVarInt(DefinedPacket.readSVarInt(from), to);
+
+    static public final Rewrite SK_VARINT = (from, to, oldId, newId) ->
+            DefinedPacket.writeVarInt(DefinedPacket.readVarInt(from), to);
+
+    static public final Rewrite VARLONG = (from, to, oldId, newId) -> {
+        final long id = DefinedPacket.readVarLong(from);
+        DefinedPacket.writeVarLong(id == oldId ? newId : (id == newId ? oldId : id), to);
+    };
+
+    static public final Rewrite SVARLONG = (from, to, oldId, newId) -> {
+        final long id = DefinedPacket.readSVarLong(from);
+        DefinedPacket.writeSVarLong(id == oldId ? newId : (id == newId ? oldId : id), to);
+    };
+
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEBlockPalette.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEBlockPalette.java
new file mode 100644
index 00000000..0037f220
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEBlockPalette.java
@@ -0,0 +1,161 @@
+package network.ycc.waterdog.pe;
+
+import com.google.common.collect.MapMaker;
+
+import io.netty.buffer.ByteBuf;
+
+import it.unimi.dsi.fastutil.objects.Object2ShortLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2ShortMap;
+import it.unimi.dsi.fastutil.shorts.Short2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.shorts.Short2ObjectMap;
+
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+import org.apache.commons.lang3.tuple.Pair;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentMap;
+
+public final class PEBlockPalette {
+
+    static ConcurrentMap<UUID, PEBlockPalette> paletteCache =
+            new MapMaker().weakValues().concurrencyLevel(8).makeMap();
+
+    public static PEBlockPalette get(ByteBuf paletteData, int version) {
+        final UUID uuid = nameUUIDFromBytes(paletteData);
+        PEBlockPalette cached = paletteCache.get(uuid);
+        if (cached == null) {
+            cached = new PEBlockPalette(paletteData, version, uuid);
+            // lazy thread safe. idempotent, but might be set multiple times
+            paletteCache.put(uuid, cached);
+        }
+        return cached;
+    }
+
+    static UUID nameUUIDFromBytes(ByteBuf buf) {
+        final MessageDigest md;
+        try {
+            md = MessageDigest.getInstance("MD5");
+        } catch (NoSuchAlgorithmException nsae) {
+            throw new InternalError("MD5 not supported", nsae);
+        }
+
+        buf.markReaderIndex();
+        while (buf.isReadable()) {
+            md.update(buf.readByte());
+        }
+        buf.resetReaderIndex();
+
+        final byte[] md5Bytes = md.digest();
+        md5Bytes[6]  &= 0x0f;  /* clear version        */
+        md5Bytes[6]  |= 0x30;  /* set to version 3     */
+        md5Bytes[8]  &= 0x3f;  /* clear variant        */
+        md5Bytes[8]  |= 0x80;  /* set to IETF variant  */
+
+        long msb = 0;
+        long lsb = 0;
+        assert md5Bytes.length == 16 : "data must be 16 bytes in length";
+        for (int i = 0 ; i < 8 ; i++) {
+            msb = (msb << 8) | (md5Bytes[i] & 0xff);
+        }
+        for (int i = 8 ; i < 16 ; i++) {
+            lsb = (lsb << 8) | (md5Bytes[i] & 0xff);
+        }
+
+        return new UUID(msb, lsb);
+    }
+
+    final UUID uuid;
+
+    Object2ShortMap<BlockPair> entryToId = new Object2ShortLinkedOpenHashMap<>();
+    Short2ObjectMap<BlockPair> idToEntry = new Short2ObjectLinkedOpenHashMap<>();
+
+    public PEBlockRewrite createRewrite(PEBlockPalette to) {
+        if (PEBlockPalette.this == to || uuid.equals(to.uuid)) {
+            return PEBlockRewrite.EMPTY;
+        }
+        return new PEBlockRewrite() {
+            public int map(int id) {
+                return to.getId(getEntry(id));
+            }
+        };
+    }
+
+    PEBlockPalette(ByteBuf buf, int version, UUID uuid) {
+        this.uuid = uuid;
+
+        int id = 0;
+        while (buf.isReadable()) {
+            final String name = DefinedPacket.readString(buf);
+            final short data = buf.readShortLE();
+            if (version >= ProtocolConstants.MINECRAFT_PE_1_12) {
+                buf.readShortLE(); //what does this id do?
+            }
+
+            addEntry((short) id++, name, data);
+        }
+    }
+
+    void addEntry(short id, String name, short data) {
+        final BlockPair pair = new BlockPair(name, data);
+        entryToId.put(pair, id);
+        idToEntry.put(id, pair);
+    }
+
+    int getId(BlockPair entry) {
+        return entryToId.getShort(entry) & 0xFFFF;
+    }
+
+    public UUID getUUID() {
+        return uuid;
+    }
+
+    BlockPair getEntry(int id) {
+        return idToEntry.get((short) id);
+    }
+
+    public static final class BlockPair extends Pair<String, Short> {
+        final String key;
+        final short data;
+        final int hash;
+
+        public BlockPair(String name, short data) {
+            this.key = name;
+            this.data = data;
+            hash = super.hashCode();
+        }
+
+        public String getLeft() {
+            return key;
+        }
+
+        public Short getRight() {
+            return data;
+        }
+
+        public Short setValue(Short value) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int hashCode() {
+            return hash;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            } else if (obj instanceof BlockPair) {
+                final BlockPair other = (BlockPair) obj;
+                return data == other.data && key.equals(other.key);
+            }
+            return false;
+        }
+    }
+
+}
+
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PECompressor.java b/proxy/src/main/java/network/ycc/waterdog/pe/PECompressor.java
new file mode 100644
index 00000000..72ea99eb
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PECompressor.java
@@ -0,0 +1,230 @@
+package network.ycc.waterdog.pe;
+
+import static network.ycc.waterdog.pe.PENativeExt.CHUNK_FLOOR;
+import static network.ycc.waterdog.pe.PENativeExt.CHUNK_SIZE;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelOutboundHandlerAdapter;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.unix.Buffer;
+import io.netty.util.ReferenceCountUtil;
+
+import net.md_5.bungee.compress.CompressFactory;
+import net.md_5.bungee.jni.zlib.BungeeZlib;
+import net.md_5.bungee.jni.zlib.NativeZlib;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+import network.ycc.raknet.RakNet;
+import network.ycc.raknet.pipeline.FlushTickHandler;
+import network.ycc.waterdog.api.metrics.RakNetMetrics;
+
+import java.nio.ByteBuffer;
+import java.util.function.BiConsumer;
+import java.util.zip.DataFormatException;
+
+public class PECompressor extends ChannelOutboundHandlerAdapter {
+
+    public static final String NAME = "compress";
+
+    protected static final int MAX_POOL_BYTES = 128 * 1024;
+    protected static final int MAX_COMPONENTS = 512;
+
+    protected final BungeeZlib zlib = CompressFactory.zlib.newInstance();
+    protected boolean dirty = false;
+    protected CompositeByteBuf outBuffer, inBuffer;
+    protected ByteBuf headerTmp, outTmp, inTmp;
+
+    @Override
+    public void handlerAdded(ChannelHandlerContext ctx) {
+        //4 is fastest without the big dropoff in compression
+        zlib.init( true, 4 );
+        outBuffer = ctx.alloc().compositeDirectBuffer(MAX_COMPONENTS);
+        inBuffer = ctx.alloc().compositeDirectBuffer(MAX_COMPONENTS);
+        headerTmp = ctx.alloc().directBuffer(8, 8);
+        outTmp = ctx.alloc().directBuffer(CHUNK_SIZE, CHUNK_SIZE);
+        inTmp = ctx.alloc().directBuffer(CHUNK_SIZE, CHUNK_SIZE);
+    }
+
+    @Override
+    public void handlerRemoved(ChannelHandlerContext ctx) {
+        zlib.free();
+        ReferenceCountUtil.safeRelease(outBuffer);
+        ReferenceCountUtil.safeRelease(inBuffer);
+        ReferenceCountUtil.safeRelease(headerTmp);
+        ReferenceCountUtil.safeRelease(outTmp);
+        ReferenceCountUtil.safeRelease(inTmp);
+    }
+
+    @Override
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+        if (msg instanceof ByteBuf) {
+            final ByteBuf buf = (ByteBuf) msg;
+            try {
+                promise.trySuccess();
+                if (!buf.isReadable()) {
+                    return;
+                }
+                if (inBuffer.readableBytes() > MAX_POOL_BYTES) {
+                    flushData(ctx);
+                }
+                metricsIncrement(ctx, 4 + buf.readableBytes(), RakNetMetrics::preCompressionBytes);
+                if (zlib instanceof NativeZlib) {
+                    if (buf.readableBytes() >= (inTmp.writableBytes() - 5)) {
+                        //big packets are fine to encode per packet
+                        flushInTmp(ctx);
+                        DefinedPacket.writeVarInt(buf.readableBytes(), headerTmp.clear());
+                        nativeDeflatePacket(headerTmp, ctx.alloc());
+                        nativeDeflatePacket(buf, ctx.alloc());
+                    } else {
+                        //otherwise fill the aggregate buffer when possible, for performance
+                        DefinedPacket.writeVarInt(buf.readableBytes(), inTmp);
+                        inTmp.writeBytes(buf);
+                    }
+                } else {
+                    final ByteBuf header = ctx.alloc().directBuffer(8, 8);
+                    DefinedPacket.writeVarInt(buf.readableBytes(), header);
+                    inBuffer.addComponent(true, header);
+                    inBuffer.addComponent(true, buf.retain());
+                }
+                dirty = true;
+                if (outBuffer.readableBytes() > MAX_POOL_BYTES) {
+                    flushData(ctx);
+                }
+                metricsIncrement(ctx, 1, RakNetMetrics::preCompressionPacket);
+                FlushTickHandler.checkFlushTick(ctx.channel());
+            } finally {
+                ReferenceCountUtil.safeRelease(msg);
+            }
+        } else {
+            ctx.write(msg, promise);
+        }
+    }
+
+    @Override
+    public void flush(ChannelHandlerContext ctx) throws Exception {
+        if (dirty) {
+            flushData(ctx);
+        }
+        ctx.flush();
+    }
+
+    protected void flushInTmp(ChannelHandlerContext ctx) {
+        nativeDeflatePacket(inTmp, ctx.alloc());
+        inTmp.clear();
+    }
+
+    protected void nativeDeflatePacket(ByteBuf in, ByteBufAllocator alloc) {
+        if (!in.isReadable()) {
+            return;
+        } else if (in.hasMemoryAddress()) {
+            nativeDeflatePacketSingle(in, alloc);
+        } else {
+            nativeDeflatePacketComposite(in, alloc);
+        }
+    }
+
+    protected void nativeDeflatePacketSingle(ByteBuf in, ByteBufAllocator alloc) {
+        final NativeZlib nzl = (NativeZlib) zlib;
+
+        while (in.isReadable()) {
+            checkOutBufferFloor(alloc);
+
+            final int processed = nzl.processEx(
+                    in.memoryAddress() + in.readerIndex(), in.readableBytes(),
+                    outTmp.memoryAddress() + outTmp.writerIndex(), outTmp.writableBytes());
+
+            outTmp.writerIndex(outTmp.writerIndex() + processed);
+            in.readerIndex(in.readerIndex() + nzl.getConsumed());
+        }
+    }
+
+    protected void nativeDeflatePacketComposite(ByteBuf in, ByteBufAllocator alloc) {
+        final NativeZlib nzl = (NativeZlib) zlib;
+        final ByteBuffer[] buffers = in.nioBuffers();
+        int bufferIndex = 0;
+
+        while (bufferIndex != buffers.length) {
+            checkOutBufferFloor(alloc);
+
+            final ByteBuffer inChunk = buffers[bufferIndex];
+            final int processed = nzl.processEx(
+                    Buffer.memoryAddress(inChunk) + inChunk.position(), inChunk.remaining(),
+                    outTmp.memoryAddress() + outTmp.writerIndex(), outTmp.writableBytes());
+
+            outTmp.writerIndex(outTmp.writerIndex() + processed);
+            inChunk.position(inChunk.position() + nzl.getConsumed());
+
+            if (!inChunk.hasRemaining()) {
+                bufferIndex++;
+            }
+        }
+
+        in.readerIndex(in.readerIndex() + in.readableBytes());
+    }
+
+    protected void nativeDeflateFinish(ByteBufAllocator alloc) {
+        final NativeZlib nzl = (NativeZlib) zlib;
+        while (!nzl.getFinished()) {
+            checkOutBufferFloor(alloc);
+
+            final int processed = nzl.processEx(
+                    0, 0,
+                    outTmp.memoryAddress() + outTmp.writerIndex(), outTmp.writableBytes());
+
+            outTmp.writerIndex(outTmp.writerIndex() + processed);
+        }
+
+        if (outTmp.isReadable()) {
+            outBuffer.addComponent(true, outTmp);
+            outTmp = alloc.directBuffer(CHUNK_SIZE, CHUNK_SIZE);
+        }
+
+        nzl.doReset();
+    }
+
+    protected void checkOutBufferFloor(ByteBufAllocator alloc) {
+        if (outTmp.writableBytes() < CHUNK_FLOOR) {
+            outBuffer.addComponent(true, outTmp);
+            outTmp = alloc.directBuffer(CHUNK_SIZE, CHUNK_SIZE);
+        }
+    }
+
+    protected void flushDataNative(ChannelHandlerContext ctx) {
+        nativeDeflateFinish(ctx.alloc());
+        final ByteBuf out = outBuffer;
+        outBuffer = ctx.alloc().compositeDirectBuffer(MAX_COMPONENTS);
+        metricsIncrement(ctx, out.readableBytes(), RakNetMetrics::postCompressionBytes);
+        ctx.write(out).addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+    }
+
+    protected void flushDataNonNative(ChannelHandlerContext ctx) throws DataFormatException {
+        final ByteBuf out = ctx.alloc().directBuffer(inBuffer.readableBytes() / 4 + 16);
+        metricsIncrement(ctx, inBuffer.readableBytes(), RakNetMetrics::preCompressionBytes);
+        zlib.process(inBuffer, out);
+        inBuffer.release();
+        inBuffer = ctx.alloc().compositeDirectBuffer(MAX_COMPONENTS);
+        metricsIncrement(ctx, out.readableBytes(), RakNetMetrics::postCompressionBytes);
+        ctx.write(out).addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+    }
+
+    protected void flushData(ChannelHandlerContext ctx) throws DataFormatException {
+        dirty = false;
+        if (zlib instanceof NativeZlib) {
+            flushInTmp(ctx);
+            flushDataNative(ctx);
+        } else {
+            flushDataNonNative(ctx);
+        }
+    }
+
+    protected void metricsIncrement(ChannelHandlerContext ctx, int i, BiConsumer<RakNetMetrics, Integer> consumer) {
+        final RakNet.MetricsLogger metrics = ctx.channel().config().getOption(RakNet.METRICS);
+        if (metrics instanceof RakNetMetrics) {
+            consumer.accept((RakNetMetrics) metrics, i);
+        }
+    }
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEDecompressor.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEDecompressor.java
new file mode 100644
index 00000000..e6f50f44
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEDecompressor.java
@@ -0,0 +1,39 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.ReferenceCountUtil;
+
+import net.md_5.bungee.compress.PacketDecompressor;
+import net.md_5.bungee.jni.zlib.NativeZlib;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+import java.util.List;
+
+public class PEDecompressor extends PacketDecompressor {
+
+    public static final String NAME = "decompress";
+
+    public PEDecompressor() {
+        super(0);
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf buf, List<Object> out) throws Exception {
+        ByteBuf data = null;
+        try {
+            if (getZlib() instanceof NativeZlib) {
+                data = PENativeExt.inflateZlibComposite((NativeZlib) getZlib(), buf, ctx.alloc());
+            } else {
+                data = ctx.alloc().ioBuffer(buf.readableBytes() * 4);
+                getZlib().process(buf, data);
+            }
+            while (data.isReadable()) {
+                out.add(data.readRetainedSlice(DefinedPacket.readVarInt(data)));
+            }
+        } finally {
+            ReferenceCountUtil.safeRelease(data);
+        }
+    }
+
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEDimSwitchLock.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEDimSwitchLock.java
new file mode 100644
index 00000000..4f50e2e3
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEDimSwitchLock.java
@@ -0,0 +1,103 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.ScheduledFuture;
+
+import net.md_5.bungee.BungeeCord;
+
+import java.util.ArrayDeque;
+import java.util.Queue;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Lock outbound packet stream until we get a dim switch ack.
+ */
+public class PEDimSwitchLock extends ChannelDuplexHandler {
+
+    public static final String NAME = "peproxy-dimlock";
+
+    protected static int MAX_QUEUE_SIZE = 8192;
+    protected static int DIM_ACK_TIMEOUT_MILLIS = 15000;
+
+    protected final Queue<ByteBuf> queue = new ArrayDeque<>(32);
+    protected boolean isLocked = false;
+    protected ScheduledFuture<?> timeoutTimer = null;
+
+    public static boolean isChannelLocked(Channel channel) {
+        final PEDimSwitchLock thiz = (PEDimSwitchLock) channel.pipeline().get(NAME);
+        return thiz != null ? thiz.isLocked : false;
+    }
+
+    @Override
+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
+        super.channelUnregistered(ctx);
+        queue.forEach(ReferenceCountUtil::safeRelease);
+        queue.clear();
+        stopTimeout();
+    }
+
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
+        if (msg instanceof ByteBuf) {
+            if(isLocked && PERawPacketData.isDimSwitchAck((ByteBuf) msg)) {
+                doUnlock(ctx);
+            }
+        }
+        ctx.fireChannelRead(msg);
+    }
+
+    @Override
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
+        if (msg instanceof ByteBuf) {
+            if (isLocked) {
+                queue.add((ByteBuf) msg);
+                promise.trySuccess();
+                if (queue.size() > MAX_QUEUE_SIZE) {
+                    BungeeCord.getInstance().getLogger().warning(
+                            "PEDimSwitchLock: queue got too large, closing connection.");
+                    ctx.channel().close();
+                }
+                return;
+            } else if (PERawPacketData.peekPacketId((ByteBuf) msg)
+                    == PERawPacketData.EXT_PS_AWAIT_DIM_SWITCH_ACK_ID) {
+                isLocked = true;
+                startTimeout(ctx);
+                ctx.fireChannelWritabilityChanged(); //alert UpstreamBridge
+                return;
+            }
+        }
+        ctx.write(msg, promise);
+    }
+
+    protected void startTimeout(ChannelHandlerContext ctx) {
+        stopTimeout();
+        timeoutTimer = ctx.channel().eventLoop().schedule(() -> {
+            BungeeCord.getInstance().getLogger().warning(
+                    "PEDimSwitchLock: Dim switch ack timeout. Resuming...");
+            doUnlock(ctx);
+        }, DIM_ACK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+    }
+
+    protected void stopTimeout() {
+        if (timeoutTimer != null) {
+            timeoutTimer.cancel(false);
+            timeoutTimer = null;
+        }
+    }
+
+    protected void doUnlock(ChannelHandlerContext ctx) {
+        isLocked = false;
+        stopTimeout();
+        ctx.fireChannelWritabilityChanged(); //alert UpstreamBridge
+        while (!queue.isEmpty() && !isLocked) {
+            write(ctx, queue.remove(), ctx.voidPromise());
+        }
+        ctx.flush();
+    }
+
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEEncryptionInitializer.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEEncryptionInitializer.java
new file mode 100644
index 00000000..366103e9
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEEncryptionInitializer.java
@@ -0,0 +1,210 @@
+package network.ycc.waterdog.pe;
+
+import com.google.gson.JsonObject;
+
+import com.nimbusds.jose.JWSObject;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOutboundHandlerAdapter;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.DecoderException;
+import io.netty.util.ReferenceCountUtil;
+
+import lombok.Getter;
+
+import net.md_5.bungee.EncryptionUtil;
+import net.md_5.bungee.jni.cipher.BungeeCipher;
+import net.md_5.bungee.jni.cipher.NativeCipher;
+import net.md_5.bungee.netty.PipelineUtils;
+
+import network.ycc.waterdog.pe.packet.PEEncryptionRequest;
+
+import javax.crypto.KeyAgreement;
+import javax.crypto.spec.SecretKeySpec;
+
+import java.security.*;
+import java.security.spec.InvalidKeySpecException;
+import java.text.ParseException;
+import java.util.Base64;
+
+public class PEEncryptionInitializer extends ChannelInitializer<Channel> {
+    public static final int HASH_LENGTH = 8;
+    private static final SecureRandom numberGenerator = new SecureRandom();
+
+    @Getter
+    private final PEEncryptionRequest request;
+    private final byte[] keyBytes;
+    private final SecretKeySpec serverKey;
+    private ByteBuf hashBuffer;
+    private ByteBuf keyBuffer;
+    private int hashBufferReader;
+
+    public PEEncryptionInitializer(PublicKey publicKey) throws NoSuchAlgorithmException, InvalidKeyException {
+        final MessageDigest digest = MessageDigest.getInstance("SHA-256");
+        final JsonObject additionalData = new JsonObject();
+        final String saltString = createSalt();
+        final KeyAgreement ka = KeyAgreement.getInstance("ECDH");
+        ka.init(PEEncryptionUtils.getKeyPair().getPrivate());
+        ka.doPhase(publicKey, true);
+        digest.update(Base64.getDecoder().decode(saltString));
+        digest.update(ka.generateSecret());
+        additionalData.addProperty("salt", saltString);
+        keyBytes = digest.digest();
+        serverKey = new SecretKeySpec(keyBytes, "AES");
+        request = new PEEncryptionRequest(PEEncryptionUtils.encodeJWT(additionalData));
+    }
+
+    public PEEncryptionInitializer(PEEncryptionRequest request) throws NoSuchAlgorithmException, ParseException,
+            InvalidKeySpecException, InvalidKeyException {
+        final MessageDigest digest = MessageDigest.getInstance("SHA-256");
+        final JWSObject additionalData = JWSObject.parse(request.getJwtData());
+        final PublicKey publicKey = PEEncryptionUtils.parseKey(additionalData.getHeader().getX509CertURL().toString());
+        final String saltString = additionalData.getPayload().toJSONObject().getAsString("salt");
+        final KeyAgreement ka = KeyAgreement.getInstance("ECDH");
+        ka.init(PEEncryptionUtils.getKeyPair().getPrivate());
+        ka.doPhase(publicKey, true);
+        digest.update(Base64.getDecoder().decode(saltString));
+        digest.update(ka.generateSecret());
+        keyBytes = digest.digest();
+        serverKey = new SecretKeySpec(keyBytes, "AES");
+        this.request = request;
+    }
+
+    protected static String createSalt() {
+        final byte[] out = new byte[32];
+        numberGenerator.nextBytes(out);
+        return Base64.getEncoder().encodeToString(out);
+    }
+
+    protected void initChannel(Channel ch) throws Exception {
+        hashBuffer = ch.alloc().directBuffer(32, 32);
+        keyBuffer = ch.alloc().directBuffer(32, 32).writeBytes(keyBytes);
+        hashBufferReader = hashBuffer.readerIndex();
+
+        ch.pipeline().addBefore(PEDecompressor.NAME, PipelineUtils.DECRYPT_HANDLER,
+                new PECipherDecoder());
+        ch.pipeline().addBefore(PECompressor.NAME, PipelineUtils.ENCRYPT_HANDLER,
+                new PECipherEncoder());
+    }
+
+    protected void destroy() {
+        hashBuffer.release();
+        keyBuffer.release();
+    }
+
+    protected class PECipherDecoder extends ChannelInboundHandlerAdapter {
+        private long counter = 0;
+        private final BungeeCipher cipher;
+
+        public PECipherDecoder() throws GeneralSecurityException {
+            cipher = EncryptionUtil.getCipher(false, serverKey);
+        }
+
+        @Override
+        public void handlerRemoved(ChannelHandlerContext ctx) {
+            cipher.free();
+            destroy();
+        }
+
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            if (msg instanceof ByteBuf) {
+                //TODO: chunked in-place cipher seems to break, maybe not the hash?
+                final ByteBuf data = condenseMaybe((ByteBuf) msg, ctx.alloc());
+                //final ByteBuf data = (ByteBuf) msg;
+                try {
+                    final int readerIndex = data.readerIndex();
+                    final int writerIndex = data.writerIndex();
+                    PENativeExt.cipherInPlace(cipher, data);
+                    createHash(cipher, data.readerIndex(readerIndex).writerIndex(writerIndex - HASH_LENGTH), counter++);
+                    data.writerIndex(writerIndex);
+                    while (hashBuffer.isReadable()) {
+                        if (data.readByte() != hashBuffer.readByte()) {
+                            throw new DecoderException("Corrupt encrypted data!");
+                        }
+                    }
+                    data.readerIndex(readerIndex).writerIndex(writerIndex - HASH_LENGTH);
+                    ctx.fireChannelRead(data.retain());
+                } finally {
+                    ReferenceCountUtil.safeRelease(data);
+                }
+            } else {
+                ctx.fireChannelRead(msg);
+            }
+        }
+
+        protected ByteBuf condenseMaybe(ByteBuf buf, ByteBufAllocator alloc) {
+            if (buf.nioBufferCount() > 1) {
+                final ByteBuf out = alloc.directBuffer(buf.readableBytes());
+                out.writeBytes(buf);
+                buf.release();
+                return out;
+            } else {
+                return buf;
+            }
+        }
+    }
+
+    protected class PECipherEncoder extends ChannelOutboundHandlerAdapter {
+        private long counter = 0;
+        private final BungeeCipher cipher;
+
+        public PECipherEncoder() throws GeneralSecurityException {
+            cipher = EncryptionUtil.getCipher(true, serverKey);
+        }
+
+        @Override
+        public void handlerRemoved(ChannelHandlerContext ctx) {
+            cipher.free();
+        }
+
+        @Override
+        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+            if (msg instanceof ByteBuf) {
+                final ByteBuf data = (ByteBuf) msg;
+                final CompositeByteBuf out = ctx.alloc().compositeDirectBuffer(2);
+                final ByteBuf hashChunk = ctx.alloc().directBuffer(32, 32);
+                try {
+                    final int readerIndex = data.readerIndex();
+                    createHash(cipher, data, counter++, hashChunk);
+                    data.readerIndex(readerIndex);
+                    PENativeExt.cipherInPlace(cipher, data);
+                    PENativeExt.cipherInPlace(cipher, hashChunk);
+                    out.addComponent(true, data.retain());
+                    out.addComponent(true, hashChunk.retain());
+                    ctx.write(out.retain(), promise);
+                } finally {
+                    ReferenceCountUtil.safeRelease(msg);
+                    ReferenceCountUtil.safeRelease(out);
+                    ReferenceCountUtil.safeRelease(hashChunk);
+                }
+            } else {
+                ctx.write(msg, promise);
+            }
+        }
+    }
+
+    protected void createHash(BungeeCipher cipher, ByteBuf in, long counter) {
+        hashBuffer.readerIndex(hashBufferReader);
+        hashBuffer.writerIndex(hashBufferReader);
+
+        createHash(cipher, in, counter, hashBuffer);
+    }
+
+    protected void createHash(BungeeCipher cipher, ByteBuf in, long counter, ByteBuf out) {
+        final int readerIndex = out.readerIndex();
+        if (cipher instanceof NativeCipher) {
+            PENativeExt.staticPEHash((NativeCipher) cipher, counter, in, keyBuffer, out);
+        } else {
+            cipher.staticPEHash(counter, in, keyBuffer, out);
+        }
+
+        out.writerIndex(readerIndex + HASH_LENGTH); //need only the first 8 bytes
+    }
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEEncryptionUtils.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEEncryptionUtils.java
new file mode 100644
index 00000000..27adebeb
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEEncryptionUtils.java
@@ -0,0 +1,296 @@
+package network.ycc.waterdog.pe;
+
+import com.google.common.base.Charsets;
+import com.google.common.base.Preconditions;
+import com.google.common.reflect.TypeToken;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSyntaxException;
+
+import com.nimbusds.jose.JOSEException;
+import com.nimbusds.jose.JWSAlgorithm;
+import com.nimbusds.jose.JWSHeader;
+import com.nimbusds.jose.JWSObject;
+import com.nimbusds.jose.Payload;
+import com.nimbusds.jose.crypto.ECDSASigner;
+import com.nimbusds.jose.crypto.factories.DefaultJWSVerifierFactory;
+import com.nimbusds.jose.jwk.Curve;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.DecoderException;
+import io.netty.handler.codec.EncoderException;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+import network.ycc.waterdog.pe.packet.PEHandshake;
+
+import org.apache.commons.lang3.tuple.ImmutablePair;
+import org.apache.commons.lang3.tuple.Pair;
+
+import java.io.InputStreamReader;
+import java.math.BigInteger;
+import java.net.URI;
+import java.nio.charset.StandardCharsets;
+import java.security.KeyFactory;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.X509EncodedKeySpec;
+import java.text.ParseException;
+import java.util.Base64;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
+public class PEEncryptionUtils {
+    public static final String MOJANG_KEY = "MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8ELkixyLcwlZryUQcu1TvPOmI2B7vX83ndnWRUaXm74wFfa5f/lwQNTfrLVHa2PmenpGI6JhIMUJaWZrjmMj90NoKNFSNBuKdm8rYiXsfaz3K36x/1U26HpG0ZxK/V1V";
+
+    static final Gson GSON;
+    static final DefaultJWSVerifierFactory jwsVerifierFactory;
+    static final KeyPair keyPair;
+    static final KeyFactory keyfactory;
+    static final PublicKey mojangPublicKey;
+
+    static {
+        GSON = new GsonBuilder().setPrettyPrinting().create();
+        jwsVerifierFactory = new DefaultJWSVerifierFactory();
+        try {
+            KeyPairGenerator gen = KeyPairGenerator.getInstance("EC");
+            gen.initialize(Curve.P_384.toECParameterSpec());
+            keyPair = gen.generateKeyPair();
+        } catch (Exception e) {
+            throw new RuntimeException("Unable to generate private keypair", e);
+        }
+        try {
+            keyfactory = KeyFactory.getInstance("EC");
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException("Unable to init key factory", e);
+        }
+        try {
+            mojangPublicKey = parseKey(MOJANG_KEY);
+        } catch (InvalidKeySpecException e) {
+            throw new RuntimeException("Unable to init mojang key", e);
+        }
+    }
+
+    public static void parseHandshake(PEHandshake handshake) {
+        final ByteBuf buf = Unpooled.wrappedBuffer(handshake.getHandshakeData());
+        final int protocolVersion = buf.readInt() - ProtocolConstants.PE_PROTOCOL_OFFSET;
+        final ByteBuf loginData = buf.readSlice(DefinedPacket.readVarInt(buf));
+        final ByteBuf chainDataBytes = loginData.readSlice(loginData.readIntLE());
+        final ByteBuf jwsDataBytes = loginData.readSlice(loginData.readIntLE());
+        final Pair<PublicKey, JsonObject> chainData = extractChainData(GSON.fromJson(
+                new InputStreamReader(new ByteBufInputStream(chainDataBytes)),
+                new TypeToken<Map<String, List<String>>>() {}.getType()
+        ));
+        final PublicKey key = chainData.getLeft();
+        final JsonObject identityData = chainData.getRight();
+        final String jwsString = jwsDataBytes.readCharSequence(jwsDataBytes.readableBytes(), Charsets.UTF_8).toString();
+        final JWSObject additionalData;
+        try {
+            additionalData = JWSObject.parse(jwsString);
+        } catch (ParseException e) {
+            throw new DecoderException("Failed to parse jws string: " + jwsString, e);
+        }
+        final JsonObject clientInfo = GSON.fromJson(additionalData.getPayload().toString(), JsonObject.class);
+        final String serverAddr = clientInfo.get("ServerAddress").getAsString();
+        Preconditions.checkArgument(serverAddr != null, "ServerAddress is missing");
+        final String[] serverAddrSplit = serverAddr.split("[:]");
+
+        clientInfo.addProperty("Waterdog_OriginalUUID", getString(identityData, "identity"));
+
+        handshake.setClientInfo(clientInfo);
+        handshake.setUsername(getString(identityData, "displayName"));
+        if (BungeeCord.getInstance().config.isReplaceUsernameSpaces()) {
+            handshake.setUsername(handshake.getUsername().replaceAll(" ", "_"));
+        }
+        handshake.setUuid(UUID.fromString(getString(identityData, "identity")));
+        handshake.setLoginUUID(handshake.getUuid());
+        handshake.setAuthorized(key != null);
+        if (handshake.isAuthorized()) {
+            handshake.setPublicKey(key);
+            handshake.setXuid(new BigInteger(getString(identityData, "XUID")));
+            if (BungeeCord.getInstance().config.isUseXUIDForUUID()) {
+                handshake.setUuid(new UUID(0, handshake.getXuid().longValue()));
+            }
+            Preconditions.checkArgument(handshake.getXuid().signum() == 1, "XUID is negative or zero");
+        }
+        handshake.setHost(serverAddrSplit[0]);
+        if (serverAddrSplit.length > 1) {
+            handshake.setPort(Integer.parseInt(serverAddrSplit[1]));
+        }
+        handshake.setProtocolVersion(protocolVersion);
+        handshake.setRequestedProtocol(2);
+    }
+
+    public static void createHandshake(PEHandshake handshake) {
+        final ByteBuf buf = Unpooled.buffer(512);
+        final byte[] identityData = createIdentityData(handshake.getUsername(),
+                handshake.getUuid(), handshake.getXuid()).getBytes(StandardCharsets.UTF_8);
+        final byte[] clientData = createClientData(handshake.getClientInfo(),
+                handshake.getHost(), handshake.getPort(), handshake.getUuid()).getBytes(StandardCharsets.UTF_8);
+        buf.writeInt(handshake.getProtocolVersion() + ProtocolConstants.PE_PROTOCOL_OFFSET);
+        DefinedPacket.writeVarInt(identityData.length + clientData.length + 8, buf);
+        buf.writeIntLE(identityData.length);
+        buf.writeBytes(identityData);
+        buf.writeIntLE(clientData.length);
+        buf.writeBytes(clientData);
+        handshake.setHandshakeData(new byte[buf.readableBytes()]);
+        buf.readBytes(handshake.getHandshakeData());
+    }
+
+    ////// READING
+
+    static Pair<PublicKey, JsonObject> extractChainData(Map<String, List<String>> maindata) {
+        final List<String> chain = maindata.get("chain");
+        try {
+            boolean foundMojangKey = false;
+            boolean signatureValid = false;
+            PublicKey key = mojangPublicKey;
+            for (String element : chain) {
+                final JWSObject jwsobject = JWSObject.parse(element);
+                if (!foundMojangKey && jwsobject.getHeader().getX509CertURL().toString().equals(MOJANG_KEY)) {
+                    foundMojangKey = true;
+                    signatureValid = true;
+                }
+                if (foundMojangKey && !verify(jwsobject, key)) {
+                    signatureValid = false;
+                }
+                final JsonObject jsonobject = GSON.fromJson(jwsobject.getPayload().toString(), JsonObject.class);
+                key = parseKey(getString(jsonobject, "identityPublicKey"));
+                if (jsonobject.has("extraData")) {
+                    return new ImmutablePair<>(signatureValid ? key : null, getJsonObject(jsonobject, "extraData"));
+                }
+            }
+        } catch (InvalidKeySpecException | JOSEException e) {
+            throw new DecoderException("Unable to decode login chain", e);
+        } catch (ParseException e) {
+            throw new DecoderException("Unable to parse: " + maindata, e);
+        }
+        throw new DecoderException("Unable to find extraData");
+    }
+
+    static String getString(JsonObject jsonObject, String name) {
+        if (jsonObject.has(name)) {
+            return getAsString(jsonObject.get(name), name);
+        }
+        throw new JsonSyntaxException("Missing " + name + ", expected to find a string");
+    }
+
+    static String getAsString(JsonElement jsonElement, String name) {
+        if (jsonElement.isJsonPrimitive()) {
+            return jsonElement.getAsString();
+        }
+        throw new JsonSyntaxException("Expected " + name + " to be a string, was " + toString(jsonElement));
+    }
+
+    static JsonObject getAsJsonObject(JsonElement jsonElement, String name) {
+        if (jsonElement.isJsonObject()) {
+            return jsonElement.getAsJsonObject();
+        }
+        throw new JsonSyntaxException("Expected " + name + " to be a JsonObject, was " + toString(jsonElement));
+    }
+
+    static JsonObject getJsonObject(JsonObject jsonObject, String name) {
+        if (jsonObject.has(name)) {
+            return getAsJsonObject(jsonObject.get(name), name);
+        }
+        throw new JsonSyntaxException("Missing " + name + ", expected to find an Object");
+    }
+
+    static String toString(JsonElement jsonElement) {
+        final String abbreviateMiddle = String.valueOf(jsonElement);
+        if (jsonElement == null) {
+            return "null (missing)";
+        }
+        if (jsonElement.isJsonNull()) {
+            return "null (json)";
+        }
+        if (jsonElement.isJsonArray()) {
+            return "an array (" + abbreviateMiddle + ")";
+        }
+        if (jsonElement.isJsonObject()) {
+            return "an object (" + abbreviateMiddle + ")";
+        }
+        if (jsonElement.isJsonPrimitive()) {
+            final JsonPrimitive asJsonPrimitive = jsonElement.getAsJsonPrimitive();
+            if (asJsonPrimitive.isNumber()) {
+                return "a number (" + abbreviateMiddle + ")";
+            }
+            if (asJsonPrimitive.isBoolean()) {
+                return "a boolean (" + abbreviateMiddle + ")";
+            }
+        }
+        return abbreviateMiddle;
+    }
+
+    static boolean verify(JWSObject object, PublicKey key) throws JOSEException {
+        return object.verify(jwsVerifierFactory.createJWSVerifier(object.getHeader(), key));
+    }
+
+    static public PublicKey parseKey(String key) throws InvalidKeySpecException {
+        return keyfactory.generatePublic(new X509EncodedKeySpec(Base64.getDecoder().decode(key)));
+    }
+
+    ////// WRITING
+
+    public static KeyPair getKeyPair() {
+        return keyPair;
+    }
+
+    @SuppressWarnings("serial")
+    static String createIdentityData(String username, UUID uuid, BigInteger xuid) {
+        final Map<String, List<String>> chainmap = new HashMap<>();
+        final long iat = System.currentTimeMillis() / 1000;
+        final long exp = iat + 24 * 3600;
+        final JsonObject extraData = new JsonObject();
+        final JsonObject dataChain = new JsonObject();
+        extraData.addProperty("identity", uuid.toString());
+        extraData.addProperty("displayName", username);
+        extraData.addProperty("XUID", xuid == null ? "" : xuid.toString());
+        dataChain.addProperty("nbf", iat - 3600);
+        dataChain.addProperty("exp", exp);
+        dataChain.addProperty("iat", iat);
+        dataChain.addProperty("iss", "self");
+        dataChain.addProperty("certificateAuthority", true);
+        dataChain.add("extraData", extraData);
+        dataChain.addProperty("randomNonce", UUID.randomUUID().getLeastSignificantBits());
+        dataChain.addProperty("identityPublicKey", Base64.getEncoder().encodeToString(keyPair.getPublic().getEncoded()));
+        chainmap.put("chain", Collections.singletonList(encodeJWT(dataChain)));
+        return GSON.toJson(chainmap, new TypeToken<Map<String, List<String>>>() {}.getType());
+    }
+
+    static String encodeJWT(JsonObject payload) {
+        try {
+            final JWSObject jwsobject = new JWSObject(
+                    new JWSHeader.Builder(JWSAlgorithm.ES384)
+                            .x509CertURL(new URI(Base64.getEncoder().encodeToString(keyPair.getPublic().getEncoded())))
+                            .build(),
+                    new Payload(GSON.toJson(payload))
+            );
+            jwsobject.sign(new ECDSASigner(keyPair.getPrivate(), Curve.P_384));
+            return jwsobject.serialize();
+        } catch (Exception e) {
+            throw new EncoderException("Unable to encode jwt", e);
+        }
+    }
+
+    static String createClientData(JsonObject baseClientInfo, String host, int port, UUID uuid) {
+        final JsonObject out = new JsonObject();
+        baseClientInfo.entrySet().forEach(entry -> out.add(entry.getKey(), entry.getValue()));
+        out.addProperty("ServerAddress", host + ":" + port);
+        out.addProperty("SelfSignedId", uuid.toString());
+        return encodeJWT(out);
+    }
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PENativeExt.java b/proxy/src/main/java/network/ycc/waterdog/pe/PENativeExt.java
new file mode 100644
index 00000000..eddc3303
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PENativeExt.java
@@ -0,0 +1,97 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.CompositeByteBuf;
+
+import io.netty.channel.unix.Buffer;
+
+import java.nio.ByteBuffer;
+import java.security.GeneralSecurityException;
+
+import net.md_5.bungee.jni.cipher.BungeeCipher;
+import net.md_5.bungee.jni.cipher.NativeCipher;
+import net.md_5.bungee.jni.zlib.NativeZlib;
+
+public class PENativeExt {
+    public static final int CHUNK_SIZE = 8192;
+    public static final int CHUNK_FLOOR = 512;
+
+    public static CompositeByteBuf inflateZlibComposite(NativeZlib nzl, ByteBuf in, ByteBufAllocator alloc) {
+        final CompositeByteBuf out = alloc.compositeDirectBuffer(128);
+        final ByteBuffer[] buffers = in.nioBuffers();
+        ByteBuf outChunk = alloc.directBuffer(CHUNK_SIZE, CHUNK_SIZE);
+        int bufferIndex = 0;
+
+        assert !nzl.isCompress();
+
+        while ( !nzl.getFinished() && bufferIndex != buffers.length )
+        {
+            if (outChunk.writableBytes() < CHUNK_FLOOR) {
+                out.addComponent(true, outChunk);
+                outChunk = alloc.directBuffer(CHUNK_SIZE, CHUNK_SIZE);
+            }
+
+            final ByteBuffer inChunk = buffers[Math.min(bufferIndex, buffers.length - 1)];
+
+            int processed = nzl.processEx(
+                    Buffer.memoryAddress(inChunk) + inChunk.position(), inChunk.remaining(),
+                    outChunk.memoryAddress() + outChunk.writerIndex(), outChunk.writableBytes());
+
+            inChunk.position(inChunk.position() + nzl.getConsumed());
+            outChunk.writerIndex(outChunk.writerIndex() + processed);
+
+            if (!inChunk.hasRemaining()) {
+                bufferIndex++;
+            }
+        }
+
+        if (outChunk.isReadable()) {
+            out.addComponent(true, outChunk);
+        } else {
+            outChunk.release();
+        }
+
+        nzl.doReset();
+
+        return out;
+    }
+
+    public static void staticPEHash(NativeCipher cipher, long counter, ByteBuf in, ByteBuf key, ByteBuf out) {
+        if (in.hasMemoryAddress()) {
+            cipher.staticPEHash(counter, in, key, out);
+        } else {
+            final ByteBuffer[] buffers = in.nioBuffers();
+            cipher.updateLongLE(counter);
+            for (ByteBuffer buffer : buffers) {
+                if (buffer.remaining() > 0) {
+                    cipher.updateUnsafe(Buffer.memoryAddress(buffer) + buffer.position(), buffer.remaining());
+                }
+            }
+            cipher.update(key.markReaderIndex());
+            key.resetReaderIndex();
+            cipher.digest(out);
+        }
+    }
+
+    public static void cipherInPlace(NativeCipher cipher, ByteBuf buf) {
+        if (buf.hasMemoryAddress()) {
+            cipher.cipherUnsafe(buf.memoryAddress() + buf.readerIndex(), buf.readableBytes());
+        } else {
+            final ByteBuffer[] buffers = buf.nioBuffers();
+            for (ByteBuffer buffer : buffers) {
+                if (buffer.remaining() > 0) {
+                    cipher.cipherUnsafe(Buffer.memoryAddress(buffer) + buffer.position(), buffer.remaining());
+                }
+            }
+        }
+    }
+
+    public static void cipherInPlace(BungeeCipher cipher, ByteBuf buf) throws GeneralSecurityException {
+        if (cipher instanceof NativeCipher) {
+            cipherInPlace((NativeCipher) cipher, buf);
+        } else {
+            cipher.cipher(buf.duplicate(), buf.duplicate().writerIndex(buf.readerIndex()));
+        }
+    }
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEPipelineUtils.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEPipelineUtils.java
new file mode 100644
index 00000000..33f83cc2
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEPipelineUtils.java
@@ -0,0 +1,125 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelInitializer;
+
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.WriteBufferWaterMark;
+import io.netty.channel.epoll.EpollDatagramChannel;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.channel.unix.UnixChannelOption;
+import io.netty.handler.timeout.ReadTimeoutHandler;
+import io.netty.util.ReferenceCountUtil;
+import lombok.RequiredArgsConstructor;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.config.ListenerInfo;
+import net.md_5.bungee.netty.PipelineUtils;
+import net.md_5.bungee.protocol.MinecraftDecoder;
+import net.md_5.bungee.protocol.ProtocolConstants;
+import net.md_5.bungee.query.QueryHandler;
+
+import network.ycc.raknet.pipeline.PongHandler;
+import network.ycc.raknet.pipeline.UserDataCodec;
+
+import network.ycc.waterdog.api.event.UserChannelTapEvent;
+
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class PEPipelineUtils {
+    public static final UserDataCodec MC_USER_DATA_CODEC = new UserDataCodec(0xFE);
+
+    private static final int SERVER_LOW_MARK = Integer.getInteger(
+            "network.ycc.waterdog.server_low_mark",   5 * 1024 * 1024 ); // 5 mb
+    private static final int SERVER_HIGH_MARK = Integer.getInteger(
+            "network.ycc.waterdog.server_high_mark", 10 * 1024 * 1024 ); // 10 mb
+    private static final WriteBufferWaterMark SERVER_MARK = new WriteBufferWaterMark( SERVER_LOW_MARK, SERVER_HIGH_MARK );
+
+    private static final int REUSE_LISTENERS = Integer.getInteger(
+            "network.ycc.waterdog.reuse_listeners", Runtime.getRuntime().availableProcessors());
+
+    public static final ChannelInitializer<Channel> SERVER_CHILD = new ChannelInitializer<Channel>() {
+        protected void initChannel(Channel channel) {
+            ChannelPipeline pipeline = channel.pipeline();
+            pipeline
+            .addLast(UserDataCodec.NAME, MC_USER_DATA_CODEC)
+            .addLast(PECompressor.NAME, new PECompressor())
+            .addLast(PEDecompressor.NAME, new PEDecompressor())
+            .addLast(PEDimSwitchLock.NAME, new PEDimSwitchLock())
+            .addLast(new ChannelInboundHandlerAdapter() {
+                @Override
+                public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                    if (msg instanceof network.ycc.raknet.packet.Packet) {
+                        BungeeCord.getInstance().getLogger().log(Level.FINER,
+                                "Stray RakNet packet sent to a child channel handler");
+                        ReferenceCountUtil.safeRelease(msg);
+                        return;
+                    }
+                    ctx.fireChannelRead(msg);
+                }
+            })
+            .addLast(PipelineUtils.SERVER_CHILD);
+            pipeline.replace(PongHandler.NAME, PEPongHandler.NAME, PEPongHandler.INSTANCE);
+            pipeline.replace(PipelineUtils.FRAME_DECODER, PipelineUtils.FRAME_DECODER, new ChannelInboundHandlerAdapter());
+            pipeline.replace(PipelineUtils.FRAME_PREPENDER, PipelineUtils.FRAME_PREPENDER, new ChannelInboundHandlerAdapter());
+            pipeline.get(MinecraftDecoder.class).setProtocolVersion(ProtocolConstants.MINECRAFT_PE_1_8);
+            moveTimeout(channel);
+        }
+    };
+
+    public static void moveTimeout(Channel channel) {
+        channel.eventLoop().execute(() -> {
+            //move timeout to the top of the pipeline
+            channel.pipeline().remove(PipelineUtils.TIMEOUT_HANDLER);
+            channel.pipeline().addFirst(PipelineUtils.TIMEOUT_HANDLER,
+                    new ReadTimeoutHandler( BungeeCord.getInstance().config.getTimeout(), TimeUnit.MILLISECONDS ));
+        });
+    }
+
+    public static void multiServerBootstrap(ChannelFutureListener listener, Logger logger, Supplier<ServerBootstrap> f) {
+        final ServerBootstrap bootstrap = f.get();
+        if (PipelineUtils.getDatagramChannel().equals(EpollDatagramChannel.class) && REUSE_LISTENERS > 1) {
+            logger.info("Epoll enabled, creating " + REUSE_LISTENERS + " RakNet sockets with SO_REUSEPORT");
+            bootstrap.option(UnixChannelOption.SO_REUSEPORT, true);
+            for (int i = 0 ; i < REUSE_LISTENERS ; i++) {
+                bootstrap.clone().bind().addListener(listener);
+            }
+        } else {
+            bootstrap.bind().addListener(listener);
+        }
+    }
+
+    @RequiredArgsConstructor
+    public static final class ServerChannel extends ChannelInitializer<Channel> {
+        private final ProxyServer bungee;
+        private final ListenerInfo listener;
+
+        @Override
+        protected void initChannel(Channel channel) throws Exception {
+            channel.eventLoop().execute(() -> {
+                channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {
+                    @Override
+                    public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                        if (msg instanceof DatagramPacket) {
+                            bungee.getLogger().log(Level.FINER, "Stray datagram sent to server channel handler");
+                            ReferenceCountUtil.safeRelease(msg);
+                            return;
+                        }
+                        ctx.fireChannelRead(msg);
+                    }
+                });
+            });
+            channel.config().setWriteBufferWaterMark(SERVER_MARK);
+            channel.pipeline()
+            .addLast(new PEProxyServerInfoHandler(bungee, listener))
+            .addLast(new QueryHandler(bungee, listener));
+        }
+    }
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEPongHandler.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEPongHandler.java
new file mode 100644
index 00000000..08d67c4b
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEPongHandler.java
@@ -0,0 +1,24 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+
+import net.md_5.bungee.protocol.PacketWrapper;
+import net.md_5.bungee.protocol.packet.KeepAlive;
+
+import network.ycc.raknet.RakNet;
+import network.ycc.raknet.packet.Pong;
+import network.ycc.raknet.pipeline.PongHandler;
+
+@ChannelHandler.Sharable
+public class PEPongHandler extends PongHandler {
+    public static final PEPongHandler INSTANCE = new PEPongHandler();
+
+    @Override
+    protected void channelRead0(ChannelHandlerContext ctx, Pong pong) {
+        super.channelRead0(ctx, pong);
+        final RakNet.Config config = (RakNet.Config) ctx.channel().config();
+        ctx.fireChannelRead(new PacketWrapper(new KeepAlive(config.getRTTNanos()), Unpooled.EMPTY_BUFFER));
+    }
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEProxyServerInfoHandler.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEProxyServerInfoHandler.java
new file mode 100644
index 00000000..66563ead
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEProxyServerInfoHandler.java
@@ -0,0 +1,148 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.util.ReferenceCountUtil;
+
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.ServerPing;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.api.chat.TextComponent;
+import net.md_5.bungee.api.config.ListenerInfo;
+import net.md_5.bungee.api.connection.PendingConnection;
+import net.md_5.bungee.api.event.ProxyPingEvent;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+import network.ycc.raknet.RakNet;
+import network.ycc.raknet.packet.Packet;
+import network.ycc.raknet.packet.UnconnectedPing;
+import network.ycc.raknet.packet.UnconnectedPong;
+import network.ycc.raknet.server.pipeline.UdpPacketHandler;
+
+import java.net.InetSocketAddress;
+import java.util.UUID;
+import java.util.logging.Level;
+
+public class PEProxyServerInfoHandler extends UdpPacketHandler<UnconnectedPing> {
+
+    protected final ListenerInfo listenerInfo;
+    protected final ProxyServer bungee;
+
+    public PEProxyServerInfoHandler(ProxyServer bungee, ListenerInfo listenerInfo) {
+        super(UnconnectedPing.class);
+        this.listenerInfo = listenerInfo;
+        this.bungee = bungee;
+    }
+
+    protected void handle(ChannelHandlerContext ctx, InetSocketAddress sender, UnconnectedPing ping) {
+        final RakNet.Config config = RakNet.config(ctx);
+        final long clientTime = ping.getClientTime(); //must ditch references to ping
+        final ServerPing.Protocol protocol = new ServerPing.Protocol(
+                "", //leave version blank, we do multi-version.
+                ProtocolConstants.MINECRAFT_PE_1_11 + ProtocolConstants.PE_PROTOCOL_OFFSET
+        );
+        final ServerPing.Players players = new ServerPing.Players(
+                listenerInfo.getMaxPlayers(), bungee.getOnlineCount(), new ServerPing.PlayerInfo[0]
+        );
+        final BaseComponent desc = new TextComponent(TextComponent.fromLegacyText(listenerInfo.getMotd().trim()));
+        final ServerPing serverPing = new ServerPing(protocol, players, desc, null);
+        final ProxyPingEvent ev = new ProxyPingEvent(new PingConnection(sender), serverPing, (event, throwable) -> {
+            final String response;
+            if (throwable != null) {
+                bungee.getLogger().log(Level.WARNING, "Failed processing PE ping:", throwable);
+                response = "";
+            } else {
+                final ServerPing result = event.getResponse();
+                response = String.join(";",
+                        "MCPE",
+                        result.getDescriptionComponent().toLegacyText().replace(";", "\\;"),
+                        String.valueOf(result.getVersion().getProtocol()),
+                        result.getVersion().getName(),
+                        String.valueOf(result.getPlayers().getOnline()),
+                        String.valueOf(result.getPlayers().getMax()),
+                        String.valueOf(config.getServerId())
+                );
+            }
+            final Packet pong = new UnconnectedPong(clientTime, config.getServerId(), config.getMagic(), response);
+            final ByteBuf tmpBuf = ctx.alloc().ioBuffer(pong.sizeHint());
+            try {
+                config.getCodec().encode(pong, tmpBuf);
+                for (int i = 0 ; i < 3; i++) { //send multiple responses for bad connections
+                    ctx.writeAndFlush(new DatagramPacket(tmpBuf.retainedSlice(), sender))
+                            .addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+                }
+            } finally {
+                ReferenceCountUtil.safeRelease(pong);
+                tmpBuf.release();
+            }
+        });
+        bungee.getPluginManager().callEvent(ev);
+    }
+
+    protected class PingConnection implements PendingConnection {
+
+        final InetSocketAddress remoteAddress;
+
+        PingConnection(InetSocketAddress remoteAddress) {
+            this.remoteAddress = remoteAddress;
+        }
+
+        public String getName() {
+            return null;
+        }
+
+        public int getVersion() {
+            return ProtocolConstants.MINECRAFT_PE_1_12;
+        }
+
+        public InetSocketAddress getVirtualHost() {
+            return null;
+        }
+
+        public ListenerInfo getListener() {
+            return listenerInfo;
+        }
+
+        public String getUUID() {
+            return null;
+        }
+
+        public UUID getUniqueId() {
+            return null;
+        }
+
+        public void setUniqueId(UUID uuid) {}
+
+        public boolean isOnlineMode() {
+            return bungee.getConfig().isOnlineMode();
+        }
+
+        public void setOnlineMode(boolean b) {}
+
+        public boolean isLegacy() {
+            return true;
+        }
+
+        public InetSocketAddress getAddress() {
+            return remoteAddress;
+        }
+
+        public void disconnect(String s) {}
+
+        public void disconnect(BaseComponent... baseComponents) {}
+
+        public void disconnect(BaseComponent baseComponent) {}
+
+        public boolean isConnected() {
+            return false;
+        }
+
+        public Unsafe unsafe() {
+            return x -> {};
+        }
+
+    }
+
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEResourcePackManager.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEResourcePackManager.java
new file mode 100644
index 00000000..0ed42cee
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEResourcePackManager.java
@@ -0,0 +1,89 @@
+package network.ycc.waterdog.pe;
+
+import network.ycc.waterdog.pe.packet.PEResourcePack;
+import network.ycc.waterdog.pe.packet.PEResourceStack;
+
+import io.netty.channel.Channel;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import java.util.logging.Logger;
+
+import net.md_5.bungee.connection.InitialHandler;
+
+public class PEResourcePackManager {
+    public static final PEResourcePackManager INSTANCE = new PEResourcePackManager();
+
+    private boolean loaded = false;
+    private PEResourcePackData[] resourcePacks = new PEResourcePackData[0];
+    private PEResourcePackData[] behaviorPacks = new PEResourcePackData[0];
+    private Map<UUID, PEResourcePackData> packMap = new HashMap<>();
+
+    private PEResourcePackManager() {}
+
+    public synchronized void load(Logger logger) {
+        if (loaded) {
+            return;
+        }
+        loaded = true;
+
+        final ArrayList<PEResourcePackData> rPacks = new ArrayList<>();
+        final ArrayList<PEResourcePackData> bPacks = new ArrayList<>();
+        File packsDir = new File("packs");
+
+        if (!packsDir.exists()) {
+            packsDir.mkdir();
+        }
+
+        for (File file : packsDir.listFiles()) {
+            try {
+                if (file.toString().toLowerCase().endsWith(".mcpack")) {
+                    rPacks.add(new PEZippedResourcePackData(file));
+                    logger.info("Loaded resource pack " + file.getName());
+                } else if (file.toString().toLowerCase().endsWith(".mcaddon")) {
+                    bPacks.add(new PEZippedResourcePackData(file));
+                    logger.info("Loaded behavior pack " + file.getName());
+                } else {
+                    continue;
+                }
+            } catch (FileNotFoundException e) {
+                logger.warning("File missing in pack " + file.getName() + ": " + e.getMessage());
+            } catch (Exception e) {
+                logger.warning("Failed to load pack " + file.getName() + ": " + e.getMessage());
+            }
+        }
+
+        //TODO: check for duplicates?
+        rPacks.forEach(pack -> packMap.put(pack.getUuid(), pack));
+        bPacks.forEach(pack -> packMap.put(pack.getUuid(), pack));
+
+        resourcePacks = rPacks.toArray(resourcePacks);
+        behaviorPacks = rPacks.toArray(behaviorPacks);
+    }
+
+    public PEResourcePackData get(UUID uuid) {
+        return packMap.get(uuid);
+    }
+
+    public boolean hasPacks() {
+        return resourcePacks.length != 0 || behaviorPacks.length != 0;
+    }
+
+    //TODO: lets figure out an async pattern here eventually, shave off some RAM
+    public void sendPackDataChunk(Channel channel, UUID uuid, int chunkIndex, int version) {
+        PERawPacketData.injectResourcePackData(channel, packMap.get(uuid), chunkIndex, version);
+    }
+
+    public void sendResourcePack(InitialHandler handler) {
+        handler.unsafe().sendPacket(new PEResourcePack(hasPacks(), resourcePacks, behaviorPacks));
+    }
+
+    public void sendResourceStack(InitialHandler handler) {
+        handler.unsafe().sendPacket(new PEResourceStack(hasPacks(), true, resourcePacks, behaviorPacks));
+    }
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEZippedResourcePackData.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEZippedResourcePackData.java
new file mode 100644
index 00000000..41665af3
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEZippedResourcePackData.java
@@ -0,0 +1,107 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.PooledByteBufAllocator;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.UUID;
+
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+import com.google.common.base.Preconditions;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+
+import lombok.EqualsAndHashCode;
+
+import lombok.Getter;
+import lombok.ToString;
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+@EqualsAndHashCode
+@ToString
+public class PEZippedResourcePackData implements PEResourcePackData {
+    @Getter
+    private final String name;
+    @Getter
+    private final UUID uuid;
+    @Getter
+    private final String version;
+    @Getter
+    private final byte[] sha256;
+    private final ByteBuf data;
+
+    public PEZippedResourcePackData(File file) throws IOException, IllegalArgumentException {
+        if (!file.exists()) {
+            throw new FileNotFoundException(file.toString());
+        }
+
+        final JsonObject manifest;
+        try (final ZipFile zip = new ZipFile(file)) {
+            final ZipEntry manifestEntry = zip.getEntry("manifest.json");
+            if (manifestEntry == null) {
+                throw new FileNotFoundException("manifest.json" + " in " + file.toString());
+            }
+
+            manifest = new JsonParser()
+                    .parse(new InputStreamReader(zip.getInputStream(manifestEntry), StandardCharsets.UTF_8))
+                    .getAsJsonObject();
+        }
+        checkForField(manifest, "format_version");
+        checkForField(manifest, "header");
+        checkForField(manifest, "modules");
+
+        final JsonObject header = manifest.getAsJsonObject("header");
+        checkForField(header, "description");
+        checkForField(header, "name");
+        checkForField(header, "uuid");
+        checkForField(header, "version");
+
+        final JsonArray versionArr = header.get("version").getAsJsonArray();
+
+        final byte[] fileData = Files.readAllBytes(file.toPath());
+        data = PooledByteBufAllocator.DEFAULT.ioBuffer(fileData.length).writeBytes(fileData);
+
+        try {
+            sha256 = MessageDigest.getInstance("SHA-256").digest(fileData);
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException("This JVM does not support SHA-256 digest", e);
+        }
+
+        name = header.get("name").getAsString();
+        uuid = UUID.fromString(header.get("uuid").getAsString());
+        version = versionArr.get(0).getAsString() + "." +
+                  versionArr.get(1).getAsString() + "." +
+                  versionArr.get(2).getAsString();
+    }
+
+    protected static void checkForField(JsonObject obj, String key1) {
+        Preconditions.checkArgument(obj.has(key1), "Manifest missing " + key1);
+    }
+
+    public void writeChunk(int chunkIndex, ByteBuf to, int version) {
+        final int offset = chunkIndex * CHUNK_SIZE;
+        final int length = Math.min(getSize() - offset, CHUNK_SIZE);
+        if (version >= ProtocolConstants.MINECRAFT_PE_1_13) {
+            DefinedPacket.writeVarInt(length, to);
+        } else {
+            to.writeIntLE(length);
+        }
+        to.writeBytes(data, data.readerIndex() + offset, length);
+    }
+
+    public int getSize() {
+        return data.readableBytes();
+    }
+}
diff --git a/proxy/src/main/java/protocolsupport/protocol/connection/PSInitEncapsulation.java b/proxy/src/main/java/protocolsupport/protocol/connection/PSInitEncapsulation.java
new file mode 100644
index 00000000..36072583
--- /dev/null
+++ b/proxy/src/main/java/protocolsupport/protocol/connection/PSInitEncapsulation.java
@@ -0,0 +1,40 @@
+package protocolsupport.protocol.connection;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+
+import lombok.AllArgsConstructor;
+
+import net.md_5.bungee.protocol.DefinedPacket;
+
+import java.net.InetSocketAddress;
+
+@AllArgsConstructor
+public class PSInitEncapsulation extends ChannelInboundHandlerAdapter {
+    public static final int HANDSHAKE_ID = 0;
+    public static final int CURRENT_VERSION = 1;
+
+    private final InetSocketAddress address;
+    private final boolean compression;
+
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) {
+        final ByteBuf to = ctx.alloc().heapBuffer();
+        to.writeByte(HANDSHAKE_ID);
+        DefinedPacket.writeVarInt(CURRENT_VERSION, to);
+        if (address != null) {
+            final byte[] addr = address.getAddress().getAddress();
+            to.writeBoolean(true);
+            DefinedPacket.writeVarInt(addr.length, to);
+            to.writeBytes(addr);
+            DefinedPacket.writeVarInt(address.getPort(), to);
+        } else {
+            to.writeBoolean(false);
+        }
+        to.writeBoolean(compression);
+        ctx.writeAndFlush(to);
+        ctx.fireChannelActive();
+        ctx.pipeline().remove(this);
+    }
+}
-- 
2.17.2 (Apple Git-113)

